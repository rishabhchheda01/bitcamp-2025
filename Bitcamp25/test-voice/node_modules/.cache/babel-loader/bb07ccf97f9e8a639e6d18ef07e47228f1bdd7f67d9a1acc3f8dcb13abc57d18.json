{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\n\n// This component uses the global moveSplineCursor function to control the Spline cursor\nconst SplineScript = ({\n  position\n}) => {\n  _s();\n  const lastPositionRef = useRef({\n    x: 0,\n    y: 0\n  });\n  const lastUpdateTimeRef = useRef(0);\n  const throttleThresholdRef = useRef(16); // ~60fps\n\n  useEffect(() => {\n    // Only update the position if it has changed significantly or enough time has passed\n    const now = performance.now();\n    const timeDelta = now - lastUpdateTimeRef.current;\n    const distanceDelta = Math.sqrt(Math.pow(position.x - lastPositionRef.current.x, 2) + Math.pow(position.y - lastPositionRef.current.y, 2));\n\n    // Skip if the change is minimal and not enough time has passed\n    if (distanceDelta < 1 && timeDelta < throttleThresholdRef.current) {\n      return;\n    }\n\n    // Update our references\n    lastPositionRef.current = {\n      ...position\n    };\n    lastUpdateTimeRef.current = now;\n\n    // Function to inject into the page that will handle cursor movement\n    const moveSplineCursor = () => {\n      try {\n        // Normalized coordinates (0-1)\n        const normalizedX = position.x / window.innerWidth;\n        const normalizedY = position.y / window.innerHeight;\n\n        // Try several methods to control Spline cursor\n\n        // Method 1: Using the global function if available\n        if (window.moveSplineCursor) {\n          window.moveSplineCursor(normalizedX, normalizedY);\n          return;\n        }\n\n        // Method 2: Find the Spline element and dispatch pointer events\n        const splineElement = document.querySelector('spline-viewer');\n        if (splineElement) {\n          // Get the element's bounding rectangle\n          const rect = splineElement.getBoundingClientRect();\n\n          // Calculate position relative to the spline element\n          const relX = position.x - rect.left;\n          const relY = position.y - rect.top;\n\n          // Apply smooth interpolation\n          const event = new PointerEvent('pointermove', {\n            clientX: position.x,\n            clientY: position.y,\n            bubbles: true\n          });\n          splineElement.dispatchEvent(event);\n\n          // Method 3: Try to access internal cursor of Spline viewer\n          if (splineElement._canvas && splineElement._runtime) {\n            // Internal access to Spline's cursor (this is implementation-dependent)\n            if (splineElement._runtime.updateCursor) {\n              splineElement._runtime.updateCursor(normalizedX, normalizedY);\n              return;\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error controlling Spline cursor:\", error);\n      }\n    };\n\n    // Create script element\n    const scriptEl = document.createElement('script');\n    scriptEl.innerHTML = `\n      try {\n        (${moveSplineCursor.toString()})();\n      } catch(e) {\n        console.error(\"Error in SplineScript:\", e);\n      }\n    `;\n    document.body.appendChild(scriptEl);\n\n    // Remove script element after execution\n    setTimeout(() => {\n      document.body.removeChild(scriptEl);\n    }, 0);\n  }, [position]);\n\n  // Add a debugging script that will log events on the Spline element\n  useEffect(() => {\n    const setupDebugger = () => {\n      const splineElement = document.querySelector('spline-viewer');\n      if (!splineElement) {\n        console.log(\"Spline element not found for debugging\");\n        return;\n      }\n\n      // Log every 100th event to avoid spam\n      let evtCounter = 0;\n      const logEvent = evt => {\n        evtCounter++;\n        if (evtCounter % 100 === 0) {\n          console.log(`Spline event (${evt.type})`, {\n            position: {\n              x: evt.clientX,\n              y: evt.clientY\n            },\n            target: evt.target\n          });\n        }\n      };\n\n      // Listen for mouse and pointer events\n      ['mousemove', 'pointermove'].forEach(eventType => {\n        splineElement.addEventListener(eventType, logEvent, {\n          passive: true\n        });\n      });\n      return () => {\n        ['mousemove', 'pointermove'].forEach(eventType => {\n          splineElement.removeEventListener(eventType, logEvent);\n        });\n      };\n    };\n\n    // Add the debugger script with a delay to ensure Spline is loaded\n    const debugTimer = setTimeout(setupDebugger, 2000);\n    return () => {\n      clearTimeout(debugTimer);\n    };\n  }, []);\n\n  // Add adaptive throttling based on performance\n  useEffect(() => {\n    // Measure FPS and adjust throttling\n    let frameCount = 0;\n    let lastFpsTime = performance.now();\n    let running = true;\n    const measurePerformance = () => {\n      if (!running) return;\n      frameCount++;\n      const now = performance.now();\n      const elapsed = now - lastFpsTime;\n      if (elapsed >= 1000) {\n        // Every second\n        const fps = frameCount / (elapsed / 1000);\n        frameCount = 0;\n        lastFpsTime = now;\n\n        // Adjust throttle threshold based on performance\n        if (fps < 30) {\n          // If FPS is low, throttle more aggressively\n          throttleThresholdRef.current = 32; // ~30fps\n        } else if (fps > 55) {\n          // If FPS is high, throttle less\n          throttleThresholdRef.current = 16; // ~60fps\n        }\n      }\n      requestAnimationFrame(measurePerformance);\n    };\n    requestAnimationFrame(measurePerformance);\n    return () => {\n      running = false;\n    };\n  }, []);\n  return null; // This component doesn't render anything visible\n};\n_s(SplineScript, \"5A7mXgeBE1NeWcgR1YCb7sFVEhs=\");\n_c = SplineScript;\nexport default SplineScript;\nvar _c;\n$RefreshReg$(_c, \"SplineScript\");","map":{"version":3,"names":["React","useEffect","useRef","SplineScript","position","_s","lastPositionRef","x","y","lastUpdateTimeRef","throttleThresholdRef","now","performance","timeDelta","current","distanceDelta","Math","sqrt","pow","moveSplineCursor","normalizedX","window","innerWidth","normalizedY","innerHeight","splineElement","document","querySelector","rect","getBoundingClientRect","relX","left","relY","top","event","PointerEvent","clientX","clientY","bubbles","dispatchEvent","_canvas","_runtime","updateCursor","error","console","scriptEl","createElement","innerHTML","toString","body","appendChild","setTimeout","removeChild","setupDebugger","log","evtCounter","logEvent","evt","type","target","forEach","eventType","addEventListener","passive","removeEventListener","debugTimer","clearTimeout","frameCount","lastFpsTime","running","measurePerformance","elapsed","fps","requestAnimationFrame","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/SplineScript.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\n\r\n// This component uses the global moveSplineCursor function to control the Spline cursor\r\nconst SplineScript = ({ position }) => {\r\n  const lastPositionRef = useRef({ x: 0, y: 0 });\r\n  const lastUpdateTimeRef = useRef(0);\r\n  const throttleThresholdRef = useRef(16); // ~60fps\r\n  \r\n  useEffect(() => {\r\n    // Only update the position if it has changed significantly or enough time has passed\r\n    const now = performance.now();\r\n    const timeDelta = now - lastUpdateTimeRef.current;\r\n    const distanceDelta = Math.sqrt(\r\n      Math.pow(position.x - lastPositionRef.current.x, 2) + \r\n      Math.pow(position.y - lastPositionRef.current.y, 2)\r\n    );\r\n    \r\n    // Skip if the change is minimal and not enough time has passed\r\n    if (distanceDelta < 1 && timeDelta < throttleThresholdRef.current) {\r\n      return;\r\n    }\r\n    \r\n    // Update our references\r\n    lastPositionRef.current = { ...position };\r\n    lastUpdateTimeRef.current = now;\r\n    \r\n    // Function to inject into the page that will handle cursor movement\r\n    const moveSplineCursor = () => {\r\n      try {\r\n        // Normalized coordinates (0-1)\r\n        const normalizedX = position.x / window.innerWidth;\r\n        const normalizedY = position.y / window.innerHeight;\r\n        \r\n        // Try several methods to control Spline cursor\r\n        \r\n        // Method 1: Using the global function if available\r\n        if (window.moveSplineCursor) {\r\n          window.moveSplineCursor(normalizedX, normalizedY);\r\n          return;\r\n        }\r\n        \r\n        // Method 2: Find the Spline element and dispatch pointer events\r\n        const splineElement = document.querySelector('spline-viewer');\r\n        if (splineElement) {\r\n          // Get the element's bounding rectangle\r\n          const rect = splineElement.getBoundingClientRect();\r\n          \r\n          // Calculate position relative to the spline element\r\n          const relX = position.x - rect.left;\r\n          const relY = position.y - rect.top;\r\n          \r\n          // Apply smooth interpolation\r\n          const event = new PointerEvent('pointermove', {\r\n            clientX: position.x,\r\n            clientY: position.y,\r\n            bubbles: true\r\n          });\r\n          \r\n          splineElement.dispatchEvent(event);\r\n          \r\n          // Method 3: Try to access internal cursor of Spline viewer\r\n          if (splineElement._canvas && splineElement._runtime) {\r\n            // Internal access to Spline's cursor (this is implementation-dependent)\r\n            if (splineElement._runtime.updateCursor) {\r\n              splineElement._runtime.updateCursor(normalizedX, normalizedY);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error controlling Spline cursor:\", error);\r\n      }\r\n    };\r\n\r\n    // Create script element\r\n    const scriptEl = document.createElement('script');\r\n    scriptEl.innerHTML = `\r\n      try {\r\n        (${moveSplineCursor.toString()})();\r\n      } catch(e) {\r\n        console.error(\"Error in SplineScript:\", e);\r\n      }\r\n    `;\r\n    document.body.appendChild(scriptEl);\r\n    \r\n    // Remove script element after execution\r\n    setTimeout(() => {\r\n      document.body.removeChild(scriptEl);\r\n    }, 0);\r\n  }, [position]);\r\n  \r\n  // Add a debugging script that will log events on the Spline element\r\n  useEffect(() => {\r\n    const setupDebugger = () => {\r\n      const splineElement = document.querySelector('spline-viewer');\r\n      if (!splineElement) {\r\n        console.log(\"Spline element not found for debugging\");\r\n        return;\r\n      }\r\n      \r\n      // Log every 100th event to avoid spam\r\n      let evtCounter = 0;\r\n      \r\n      const logEvent = (evt) => {\r\n        evtCounter++;\r\n        if (evtCounter % 100 === 0) {\r\n          console.log(`Spline event (${evt.type})`, {\r\n            position: { x: evt.clientX, y: evt.clientY },\r\n            target: evt.target\r\n          });\r\n        }\r\n      };\r\n      \r\n      // Listen for mouse and pointer events\r\n      ['mousemove', 'pointermove'].forEach(eventType => {\r\n        splineElement.addEventListener(eventType, logEvent, { passive: true });\r\n      });\r\n      \r\n      return () => {\r\n        ['mousemove', 'pointermove'].forEach(eventType => {\r\n          splineElement.removeEventListener(eventType, logEvent);\r\n        });\r\n      };\r\n    };\r\n    \r\n    // Add the debugger script with a delay to ensure Spline is loaded\r\n    const debugTimer = setTimeout(setupDebugger, 2000);\r\n    \r\n    return () => {\r\n      clearTimeout(debugTimer);\r\n    };\r\n  }, []);\r\n  \r\n  // Add adaptive throttling based on performance\r\n  useEffect(() => {\r\n    // Measure FPS and adjust throttling\r\n    let frameCount = 0;\r\n    let lastFpsTime = performance.now();\r\n    let running = true;\r\n    \r\n    const measurePerformance = () => {\r\n      if (!running) return;\r\n      \r\n      frameCount++;\r\n      const now = performance.now();\r\n      const elapsed = now - lastFpsTime;\r\n      \r\n      if (elapsed >= 1000) { // Every second\r\n        const fps = frameCount / (elapsed / 1000);\r\n        frameCount = 0;\r\n        lastFpsTime = now;\r\n        \r\n        // Adjust throttle threshold based on performance\r\n        if (fps < 30) {\r\n          // If FPS is low, throttle more aggressively\r\n          throttleThresholdRef.current = 32; // ~30fps\r\n        } else if (fps > 55) {\r\n          // If FPS is high, throttle less\r\n          throttleThresholdRef.current = 16; // ~60fps\r\n        }\r\n      }\r\n      \r\n      requestAnimationFrame(measurePerformance);\r\n    };\r\n    \r\n    requestAnimationFrame(measurePerformance);\r\n    \r\n    return () => {\r\n      running = false;\r\n    };\r\n  }, []);\r\n  \r\n  return null; // This component doesn't render anything visible\r\n};\r\n\r\nexport default SplineScript; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}