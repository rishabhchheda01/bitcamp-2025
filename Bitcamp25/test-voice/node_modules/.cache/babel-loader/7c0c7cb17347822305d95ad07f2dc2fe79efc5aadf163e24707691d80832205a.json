{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceCameraControl.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./simple/FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 320,\n  // Smaller resolution for better performance\n  height: 240\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\nfunction FaceCameraControl({\n  onFaceDirectionChange,\n  enabled = true,\n  showDebug = false\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [directionData, setDirectionData] = useState(null);\n  const animationFrameRef = useRef(null);\n  const lastDirectionRef = useRef({\n    horizontal: 'center',\n    vertical: 'center'\n  });\n  const lastKeyPressRef = useRef(null);\n  const keyThrottleRef = useRef(false);\n\n  // Initialize the detector\n  useEffect(() => {\n    if (!enabled) return;\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: showDebug,\n        showTagNumbers: false,\n        showDirection: showDebug,\n        drawDelay: 100 // Faster updates for more responsive controls\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enabled, showDebug]);\n\n  // Handle video load\n  const handleVideoLoad = async videoNode => {\n    const video = videoNode.target;\n    if (video.readyState !== 4 || !enabled) return;\n    if (loaded) return;\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(webcamRef.current.video, canvasRef.current, handleDirectionData);\n      setLoaded(true);\n    }\n  };\n\n  // Process face direction data and convert to key presses\n  const handleDirectionData = data => {\n    if (!data || !enabled) return;\n    setDirectionData(data);\n\n    // Calculate horizontal position (yaw indicates left/right)\n    // negative yaw = looking right, positive yaw = looking left\n    let horizontalPosition = 'center';\n    if (data.yaw < -10) {\n      horizontalPosition = 'right';\n    } else if (data.yaw > 10) {\n      horizontalPosition = 'left';\n    }\n\n    // Calculate vertical position using turn angle\n    // negative turn = looking up, positive turn = looking down\n    let verticalPosition = 'center';\n    if (data.turn < -10) {\n      verticalPosition = 'up';\n    } else if (data.turn > 10) {\n      verticalPosition = 'down';\n    }\n\n    // Determine if direction has changed\n    const direction = {\n      horizontal: horizontalPosition,\n      vertical: verticalPosition\n    };\n    const hasChanged = direction.horizontal !== lastDirectionRef.current.horizontal || direction.vertical !== lastDirectionRef.current.vertical;\n\n    // Update the last direction\n    lastDirectionRef.current = direction;\n\n    // Only send direction change if it has changed and not throttled\n    if (hasChanged && !keyThrottleRef.current) {\n      keyThrottleRef.current = true;\n\n      // Call the callback with appropriate key\n      let key = null;\n      if (direction.horizontal === 'left') key = 'l';else if (direction.horizontal === 'right') key = 'r';else if (direction.vertical === 'up') key = 'u';else if (direction.vertical === 'down') key = 'd';\n      if (key && key !== lastKeyPressRef.current) {\n        lastKeyPressRef.current = key;\n        if (onFaceDirectionChange) {\n          onFaceDirectionChange(key, direction);\n        }\n      }\n\n      // Reset throttle after delay\n      setTimeout(() => {\n        keyThrottleRef.current = false;\n      }, 300); // 300ms throttle to prevent too many rapid direction changes\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `face-camera-control ${!enabled ? 'disabled' : ''}`,\n    style: {\n      position: 'relative',\n      width: showDebug ? inputResolution.width : '100px',\n      height: showDebug ? inputResolution.height : '100px'\n    },\n    children: [!loaded && enabled && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: \"Loading face detection...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 30\n    }, this), /*#__PURE__*/_jsxDEV(Webcam, {\n      ref: webcamRef,\n      width: inputResolution.width,\n      height: inputResolution.height,\n      style: {\n        visibility: showDebug ? 'hidden' : 'visible',\n        position: showDebug ? 'absolute' : 'relative',\n        borderRadius: '50%',\n        objectFit: 'cover',\n        width: showDebug ? '100%' : '100px',\n        height: showDebug ? '100%' : '100px'\n      },\n      videoConstraints: videoConstraints,\n      onLoadedData: handleVideoLoad\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: inputResolution.width,\n      height: inputResolution.height,\n      style: {\n        display: showDebug ? 'block' : 'none',\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        border: '1px solid black'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }, this), showDebug && directionData && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"data-display\",\n      style: {\n        position: 'absolute',\n        bottom: '-120px',\n        left: 0,\n        background: 'rgba(255,255,255,0.8)',\n        padding: '5px'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Face Direction:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 168,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        children: JSON.stringify({\n          direction: lastDirectionRef.current,\n          yaw: Math.round(directionData.yaw),\n          turn: Math.round(directionData.turn)\n        }, null, 2)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 169,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 134,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceCameraControl, \"OMH1ulp3Lx84JGgDlVVt/TtvjVM=\");\n_c = FaceCameraControl;\nexport default FaceCameraControl;\nvar _c;\n$RefreshReg$(_c, \"FaceCameraControl\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","FaceCameraControl","onFaceDirectionChange","enabled","showDebug","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","directionData","setDirectionData","animationFrameRef","lastDirectionRef","horizontal","vertical","lastKeyPressRef","keyThrottleRef","initializeDetector","options","showMesh","showTagNumbers","showDirection","drawDelay","faceDetector","stop","current","cancelAnimationFrame","handleVideoLoad","videoNode","video","target","readyState","start","handleDirectionData","data","horizontalPosition","yaw","verticalPosition","turn","direction","hasChanged","key","setTimeout","className","style","position","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","visibility","borderRadius","objectFit","onLoadedData","display","top","left","border","bottom","background","padding","JSON","stringify","Math","round","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceCameraControl.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\r\nimport \"@tensorflow/tfjs\";\r\nimport \"@tensorflow/tfjs-backend-webgl\";\r\nimport \"@mediapipe/face_mesh\";\r\nimport Webcam from \"react-webcam\";\r\nimport FaceDirectionDetector from \"./simple/FaceDirectionDetector\";\r\n\r\nconst inputResolution = {\r\n  width: 320,  // Smaller resolution for better performance\r\n  height: 240,\r\n};\r\n\r\nconst videoConstraints = {\r\n  width: inputResolution.width,\r\n  height: inputResolution.height,\r\n  facingMode: \"user\",\r\n};\r\n\r\nfunction FaceCameraControl({ onFaceDirectionChange, enabled = true, showDebug = false }) {\r\n  const canvasRef = useRef(null);\r\n  const webcamRef = useRef(null);\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [detector, setDetector] = useState(null);\r\n  const [directionData, setDirectionData] = useState(null);\r\n  const animationFrameRef = useRef(null);\r\n  const lastDirectionRef = useRef({ horizontal: 'center', vertical: 'center' });\r\n  const lastKeyPressRef = useRef(null);\r\n  const keyThrottleRef = useRef(false);\r\n\r\n  // Initialize the detector\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const initializeDetector = async () => {\r\n      const options = {\r\n        showMesh: showDebug,\r\n        showTagNumbers: false,\r\n        showDirection: showDebug,\r\n        drawDelay: 100  // Faster updates for more responsive controls\r\n      };\r\n      \r\n      const faceDetector = new FaceDirectionDetector(options);\r\n      setDetector(faceDetector);\r\n    };\r\n\r\n    initializeDetector();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (detector) {\r\n        detector.stop();\r\n      }\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [enabled, showDebug]);\r\n\r\n  // Handle video load\r\n  const handleVideoLoad = async (videoNode) => {\r\n    const video = videoNode.target;\r\n    if (video.readyState !== 4 || !enabled) return;\r\n    if (loaded) return;\r\n\r\n    if (detector && webcamRef.current && canvasRef.current) {\r\n      await detector.start(\r\n        webcamRef.current.video, \r\n        canvasRef.current, \r\n        handleDirectionData\r\n      );\r\n      setLoaded(true);\r\n    }\r\n  };\r\n\r\n  // Process face direction data and convert to key presses\r\n  const handleDirectionData = (data) => {\r\n    if (!data || !enabled) return;\r\n    \r\n    setDirectionData(data);\r\n    \r\n    // Calculate horizontal position (yaw indicates left/right)\r\n    // negative yaw = looking right, positive yaw = looking left\r\n    let horizontalPosition = 'center';\r\n    if (data.yaw < -10) {\r\n      horizontalPosition = 'right';\r\n    } else if (data.yaw > 10) {\r\n      horizontalPosition = 'left';\r\n    }\r\n    \r\n    // Calculate vertical position using turn angle\r\n    // negative turn = looking up, positive turn = looking down\r\n    let verticalPosition = 'center';\r\n    if (data.turn < -10) {\r\n      verticalPosition = 'up';\r\n    } else if (data.turn > 10) {\r\n      verticalPosition = 'down';\r\n    }\r\n    \r\n    // Determine if direction has changed\r\n    const direction = { horizontal: horizontalPosition, vertical: verticalPosition };\r\n    const hasChanged = \r\n      direction.horizontal !== lastDirectionRef.current.horizontal || \r\n      direction.vertical !== lastDirectionRef.current.vertical;\r\n    \r\n    // Update the last direction\r\n    lastDirectionRef.current = direction;\r\n    \r\n    // Only send direction change if it has changed and not throttled\r\n    if (hasChanged && !keyThrottleRef.current) {\r\n      keyThrottleRef.current = true;\r\n      \r\n      // Call the callback with appropriate key\r\n      let key = null;\r\n      if (direction.horizontal === 'left') key = 'l';\r\n      else if (direction.horizontal === 'right') key = 'r';\r\n      else if (direction.vertical === 'up') key = 'u';\r\n      else if (direction.vertical === 'down') key = 'd';\r\n      \r\n      if (key && key !== lastKeyPressRef.current) {\r\n        lastKeyPressRef.current = key;\r\n        if (onFaceDirectionChange) {\r\n          onFaceDirectionChange(key, direction);\r\n        }\r\n      }\r\n      \r\n      // Reset throttle after delay\r\n      setTimeout(() => {\r\n        keyThrottleRef.current = false;\r\n      }, 300); // 300ms throttle to prevent too many rapid direction changes\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`face-camera-control ${!enabled ? 'disabled' : ''}`} style={{ position: 'relative', width: showDebug ? inputResolution.width : '100px', height: showDebug ? inputResolution.height : '100px' }}>\r\n      {!loaded && enabled && <div className=\"loading\">Loading face detection...</div>}\r\n      \r\n      <Webcam\r\n        ref={webcamRef}\r\n        width={inputResolution.width}\r\n        height={inputResolution.height}\r\n        style={{ \r\n          visibility: showDebug ? 'hidden' : 'visible', \r\n          position: showDebug ? 'absolute' : 'relative',\r\n          borderRadius: '50%',\r\n          objectFit: 'cover',\r\n          width: showDebug ? '100%' : '100px',\r\n          height: showDebug ? '100%' : '100px'\r\n        }}\r\n        videoConstraints={videoConstraints}\r\n        onLoadedData={handleVideoLoad}\r\n      />\r\n      \r\n      <canvas\r\n        ref={canvasRef}\r\n        width={inputResolution.width}\r\n        height={inputResolution.height}\r\n        style={{ \r\n          display: showDebug ? 'block' : 'none',\r\n          position: 'absolute', \r\n          top: 0,\r\n          left: 0,\r\n          border: '1px solid black' \r\n        }}\r\n      />\r\n      \r\n      {showDebug && directionData && (\r\n        <div className=\"data-display\" style={{ position: 'absolute', bottom: '-120px', left: 0, background: 'rgba(255,255,255,0.8)', padding: '5px' }}>\r\n          <h3>Face Direction:</h3>\r\n          <pre>{JSON.stringify({\r\n            direction: lastDirectionRef.current,\r\n            yaw: Math.round(directionData.yaw),\r\n            turn: Math.round(directionData.turn)\r\n          }, null, 2)}</pre>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FaceCameraControl; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}