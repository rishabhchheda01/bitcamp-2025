{"ast":null,"code":"import * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport { TRIANGULATION } from \"./triangulation\";\n\n/**\r\n * FaceDirectionDetector class\r\n * A reusable class for detecting face landmarks and calculating face direction\r\n */\nclass FaceDirectionDetector {\n  constructor(options = {}) {\n    // Default options\n    this.options = {\n      runtime: \"tfjs\",\n      showMesh: true,\n      showTagNumbers: false,\n      showDirection: true,\n      drawDelay: 300,\n      // ms\n      ...options\n    };\n    this.detector = null;\n    this.canvas = null;\n    this.video = null;\n    this.isRunning = false;\n    this.animationId = null;\n  }\n\n  /**\r\n   * Initialize the detector\r\n   * @returns {Promise<void>}\r\n   */\n  async initialize() {\n    const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\n    const detectorConfig = {\n      runtime: this.options.runtime\n    };\n    this.detector = await faceLandmarksDetection.createDetector(model, detectorConfig);\n  }\n\n  /**\r\n   * Start the face direction detection process\r\n   * @param {HTMLVideoElement} video - Video element to detect faces from\r\n   * @param {HTMLCanvasElement} canvas - Canvas element to draw on\r\n   * @param {Function} callback - Callback function to receive direction data\r\n   * @returns {Promise<void>}\r\n   */\n  async start(video, canvas, callback) {\n    if (!this.detector) {\n      await this.initialize();\n    }\n    this.video = video;\n    this.canvas = canvas;\n    this.callback = callback;\n    this.isRunning = true;\n    this.detect();\n  }\n\n  /**\r\n   * Stop the detection process\r\n   */\n  stop() {\n    this.isRunning = false;\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n\n  /**\r\n   * Set options for the detector\r\n   * @param {Object} options - Options to set\r\n   */\n  setOptions(options) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n  }\n\n  /**\r\n   * Main detection loop\r\n   */\n  async detect() {\n    if (!this.isRunning) return;\n    const estimationConfig = {\n      flipHorizontal: true\n    };\n    const faces = await this.detector.estimateFaces(this.video, estimationConfig);\n    const ctx = this.canvas.getContext(\"2d\");\n    setTimeout(() => {\n      this.animationId = requestAnimationFrame(() => {\n        if (faces && faces.length > 0) {\n          const data = this.drawMesh(faces[0], ctx);\n          if (this.callback) {\n            // Pass the full face data to the callback\n            this.callback({\n              ...data,\n              keypoints: faces[0].keypoints\n            });\n          }\n        }\n        if (this.isRunning) {\n          this.detect();\n        }\n      });\n    }, this.options.drawDelay);\n  }\n\n  /**\r\n   * Draw the face mesh on canvas and calculate direction\r\n   * @param {Object} prediction - Face prediction data\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @returns {Object} Direction data\r\n   */\n  drawMesh(prediction, ctx) {\n    if (!prediction) return;\n    const keyPoints = prediction.keypoints;\n    if (!keyPoints || keyPoints.length === 0) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Draw and calculate\n    this.drawFaceMesh(ctx, keyPoints);\n    return this.calculateDirection(ctx, keyPoints);\n  }\n\n  /**\r\n   * Draw face mesh on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   */\n  drawFaceMesh(ctx, keyPoints) {\n    if (this.options.showMesh) {\n      this.drawMeshPaths(keyPoints, ctx);\n    }\n    if (this.options.showTagNumbers) {\n      let index = 0;\n      for (let keyPoint of keyPoints) {\n        ctx.beginPath();\n        ctx.arc(keyPoint.x, keyPoint.y, 1, 0, 3 * Math.PI);\n        ctx.fillText(index, keyPoint.x, keyPoint.y);\n        ctx.fillStyle = \"black\";\n        ctx.fill();\n        index++;\n      }\n    }\n  }\n\n  /**\r\n   * Draw mesh paths on canvas\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   */\n  drawMeshPaths(keyPoints, ctx) {\n    for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n      const points = [TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1], TRIANGULATION[i * 3 + 2]].map(index => keyPoints[index]);\n      this.drawPath(ctx, points, true);\n    }\n  }\n\n  /**\r\n   * Draw a path on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} points - Points to draw\r\n   * @param {boolean} closePath - Whether to close the path\r\n   */\n  drawPath(ctx, points, closePath) {\n    const region = new Path2D();\n    region.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      const point = points[i];\n      region.lineTo(point.x, point.y);\n    }\n    if (closePath) {\n      region.closePath();\n    }\n    ctx.strokeStyle = \"black\";\n    ctx.stroke(region);\n  }\n\n  /**\r\n   * Calculate face direction based on keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @returns {Object} Direction data\r\n   */\n  calculateDirection(ctx, keyPoints) {\n    let noseTip, leftNose, rightNose;\n    try {\n      noseTip = {\n        ...keyPoints[1],\n        name: \"nose tip\"\n      };\n      leftNose = {\n        ...keyPoints[279],\n        name: \"left nose\"\n      };\n      rightNose = {\n        ...keyPoints[49],\n        name: \"right nose\"\n      };\n    } catch (error) {\n      console.log(\"Error creating directional points\", keyPoints, error);\n      return null;\n    }\n\n    // Midsection of nose is back of nose perpendicular\n    const midpoint = {\n      x: (leftNose.x + rightNose.x) / 2,\n      y: (leftNose.y + rightNose.y) / 2,\n      z: (leftNose.z + rightNose.z) / 2\n    };\n    const perpendicularUp = {\n      x: midpoint.x,\n      y: midpoint.y - 50,\n      z: midpoint.z\n    };\n\n    // Calculate angles\n    const yaw = this.getAngleBetweenLines(midpoint, noseTip, perpendicularUp);\n    const turn = this.getAngleBetweenLines(midpoint, rightNose, noseTip);\n    if (this.options.showDirection) {\n      // Draw the direction indicators\n      this.drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn);\n    }\n\n    // Calculate distance between nose tip and midpoint, and left and right nose points\n    const zDistance = this.getDistanceBetweenPoints(noseTip, midpoint);\n    const xDistance = this.getDistanceBetweenPoints(leftNose, rightNose);\n    return {\n      yaw,\n      turn,\n      zDistance,\n      xDistance\n    };\n  }\n\n  /**\r\n   * Draw direction indicators on canvas\r\n   */\n  drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn) {\n    // Draw the turn angle\n    const region2 = new Path2D();\n    region2.moveTo(leftNose.x, leftNose.y);\n    region2.lineTo(rightNose.x, rightNose.y);\n    ctx.strokeStyle = \"blue\";\n    ctx.stroke(region2);\n\n    // Draw the yaw angle\n    const region3 = new Path2D();\n    region3.moveTo(midpoint.x, midpoint.y);\n    region3.lineTo(noseTip.x, noseTip.y);\n    ctx.strokeStyle = \"red\";\n    ctx.stroke(region3);\n\n    // Draw the perpendicular line\n    const region4 = new Path2D();\n    region4.moveTo(midpoint.x, midpoint.y);\n    region4.lineTo(perpendicularUp.x, perpendicularUp.y);\n    ctx.strokeStyle = \"green\";\n    ctx.stroke(region4);\n\n    // Display the angle values\n    ctx.font = \"14px Arial\";\n    ctx.fillStyle = \"black\";\n    ctx.fillText(`Yaw: ${yaw.toFixed(2)}째`, 10, 20);\n    ctx.fillText(`Turn: ${turn.toFixed(2)}째`, 10, 40);\n  }\n\n  /**\r\n   * Calculate distance between two 3D points\r\n   * @param {Object} point1 - First point {x, y, z}\r\n   * @param {Object} point2 - Second point {x, y, z}\r\n   * @returns {number} Distance between points\r\n   */\n  getDistanceBetweenPoints(point1, point2) {\n    const dx = point1.x - point2.x;\n    const dy = point1.y - point2.y;\n    const dz = point1.z - point2.z;\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  /**\r\n   * Calculate angle between two lines that share a midpoint\r\n   * @param {Object} midpoint - Shared point {x, y, z}\r\n   * @param {Object} point1 - End of first line {x, y, z}\r\n   * @param {Object} point2 - End of second line {x, y, z}\r\n   * @returns {number} Angle in degrees\r\n   */\n  getAngleBetweenLines(midpoint, point1, point2) {\n    // Vector 1\n    const v1 = {\n      x: point1.x - midpoint.x,\n      y: point1.y - midpoint.y,\n      z: point1.z - midpoint.z\n    };\n\n    // Vector 2\n    const v2 = {\n      x: point2.x - midpoint.x,\n      y: point2.y - midpoint.y,\n      z: point2.z - midpoint.z\n    };\n\n    // Dot product\n    const dotProduct = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n\n    // Magnitudes\n    const v1Mag = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);\n    const v2Mag = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);\n\n    // Angle\n    const cosAngle = dotProduct / (v1Mag * v2Mag);\n    return Math.acos(Math.min(Math.max(cosAngle, -1), 1)) * (180 / Math.PI);\n  }\n}\nexport default FaceDirectionDetector;","map":{"version":3,"names":["faceLandmarksDetection","TRIANGULATION","FaceDirectionDetector","constructor","options","runtime","showMesh","showTagNumbers","showDirection","drawDelay","detector","canvas","video","isRunning","animationId","initialize","model","SupportedModels","MediaPipeFaceMesh","detectorConfig","createDetector","start","callback","detect","stop","cancelAnimationFrame","setOptions","estimationConfig","flipHorizontal","faces","estimateFaces","ctx","getContext","setTimeout","requestAnimationFrame","length","data","drawMesh","keypoints","prediction","keyPoints","clearRect","width","height","drawFaceMesh","calculateDirection","drawMeshPaths","index","keyPoint","beginPath","arc","x","y","Math","PI","fillText","fillStyle","fill","i","points","map","drawPath","closePath","region","Path2D","moveTo","point","lineTo","strokeStyle","stroke","noseTip","leftNose","rightNose","name","error","console","log","midpoint","z","perpendicularUp","yaw","getAngleBetweenLines","turn","drawDirectionIndicators","zDistance","getDistanceBetweenPoints","xDistance","region2","region3","region4","font","toFixed","point1","point2","dx","dy","dz","sqrt","v1","v2","dotProduct","v1Mag","v2Mag","cosAngle","acos","min","max"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDirectionDetector.js"],"sourcesContent":["import * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\r\nimport { TRIANGULATION } from \"./triangulation\";\r\n\r\n/**\r\n * FaceDirectionDetector class\r\n * A reusable class for detecting face landmarks and calculating face direction\r\n */\r\nclass FaceDirectionDetector {\r\n  constructor(options = {}) {\r\n    // Default options\r\n    this.options = {\r\n      runtime: \"tfjs\",\r\n      showMesh: true,\r\n      showTagNumbers: false,\r\n      showDirection: true,\r\n      drawDelay: 300, // ms\r\n      ...options\r\n    };\r\n    \r\n    this.detector = null;\r\n    this.canvas = null;\r\n    this.video = null;\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize the detector\r\n   * @returns {Promise<void>}\r\n   */\r\n  async initialize() {\r\n    const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\r\n    const detectorConfig = {\r\n      runtime: this.options.runtime,\r\n    };\r\n    \r\n    this.detector = await faceLandmarksDetection.createDetector(\r\n      model,\r\n      detectorConfig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Start the face direction detection process\r\n   * @param {HTMLVideoElement} video - Video element to detect faces from\r\n   * @param {HTMLCanvasElement} canvas - Canvas element to draw on\r\n   * @param {Function} callback - Callback function to receive direction data\r\n   * @returns {Promise<void>}\r\n   */\r\n  async start(video, canvas, callback) {\r\n    if (!this.detector) {\r\n      await this.initialize();\r\n    }\r\n    \r\n    this.video = video;\r\n    this.canvas = canvas;\r\n    this.callback = callback;\r\n    this.isRunning = true;\r\n    \r\n    this.detect();\r\n  }\r\n\r\n  /**\r\n   * Stop the detection process\r\n   */\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n      this.animationId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set options for the detector\r\n   * @param {Object} options - Options to set\r\n   */\r\n  setOptions(options) {\r\n    this.options = {\r\n      ...this.options,\r\n      ...options\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Main detection loop\r\n   */\r\n  async detect() {\r\n    if (!this.isRunning) return;\r\n    \r\n    const estimationConfig = { flipHorizontal: true };\r\n    const faces = await this.detector.estimateFaces(this.video, estimationConfig);\r\n    const ctx = this.canvas.getContext(\"2d\");\r\n    \r\n    setTimeout(() => {\r\n      this.animationId = requestAnimationFrame(() => {\r\n        if (faces && faces.length > 0) {\r\n          const data = this.drawMesh(faces[0], ctx);\r\n          if (this.callback) {\r\n            // Pass the full face data to the callback\r\n            this.callback({\r\n              ...data,\r\n              keypoints: faces[0].keypoints\r\n            });\r\n          }\r\n        }\r\n        \r\n        if (this.isRunning) {\r\n          this.detect();\r\n        }\r\n      });\r\n    }, this.options.drawDelay);\r\n  }\r\n\r\n  /**\r\n   * Draw the face mesh on canvas and calculate direction\r\n   * @param {Object} prediction - Face prediction data\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @returns {Object} Direction data\r\n   */\r\n  drawMesh(prediction, ctx) {\r\n    if (!prediction) return;\r\n    const keyPoints = prediction.keypoints;\r\n    if (!keyPoints || keyPoints.length === 0) return;\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw and calculate\r\n    this.drawFaceMesh(ctx, keyPoints);\r\n    return this.calculateDirection(ctx, keyPoints);\r\n  }\r\n\r\n  /**\r\n   * Draw face mesh on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   */\r\n  drawFaceMesh(ctx, keyPoints) {\r\n    if (this.options.showMesh) {\r\n      this.drawMeshPaths(keyPoints, ctx);\r\n    }\r\n    \r\n    if (this.options.showTagNumbers) {\r\n      let index = 0;\r\n      for (let keyPoint of keyPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(keyPoint.x, keyPoint.y, 1, 0, 3 * Math.PI);\r\n        ctx.fillText(index, keyPoint.x, keyPoint.y);\r\n        ctx.fillStyle = \"black\";\r\n        ctx.fill();\r\n        index++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw mesh paths on canvas\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   */\r\n  drawMeshPaths(keyPoints, ctx) {\r\n    for (let i = 0; i < TRIANGULATION.length / 3; i++) {\r\n      const points = [\r\n        TRIANGULATION[i * 3],\r\n        TRIANGULATION[i * 3 + 1],\r\n        TRIANGULATION[i * 3 + 2],\r\n      ].map((index) => keyPoints[index]);\r\n      \r\n      this.drawPath(ctx, points, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw a path on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} points - Points to draw\r\n   * @param {boolean} closePath - Whether to close the path\r\n   */\r\n  drawPath(ctx, points, closePath) {\r\n    const region = new Path2D();\r\n    region.moveTo(points[0].x, points[0].y);\r\n    \r\n    for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      region.lineTo(point.x, point.y);\r\n    }\r\n    \r\n    if (closePath) {\r\n      region.closePath();\r\n    }\r\n    \r\n    ctx.strokeStyle = \"black\";\r\n    ctx.stroke(region);\r\n  }\r\n\r\n  /**\r\n   * Calculate face direction based on keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @returns {Object} Direction data\r\n   */\r\n  calculateDirection(ctx, keyPoints) {\r\n    let noseTip, leftNose, rightNose;\r\n    \r\n    try {\r\n      noseTip = { ...keyPoints[1], name: \"nose tip\" };\r\n      leftNose = { ...keyPoints[279], name: \"left nose\" };\r\n      rightNose = { ...keyPoints[49], name: \"right nose\" };\r\n    } catch (error) {\r\n      console.log(\"Error creating directional points\", keyPoints, error);\r\n      return null;\r\n    }\r\n\r\n    // Midsection of nose is back of nose perpendicular\r\n    const midpoint = {\r\n      x: (leftNose.x + rightNose.x) / 2,\r\n      y: (leftNose.y + rightNose.y) / 2,\r\n      z: (leftNose.z + rightNose.z) / 2,\r\n    };\r\n    \r\n    const perpendicularUp = { \r\n      x: midpoint.x, \r\n      y: midpoint.y - 50, \r\n      z: midpoint.z \r\n    };\r\n\r\n    // Calculate angles\r\n    const yaw = this.getAngleBetweenLines(midpoint, noseTip, perpendicularUp);\r\n    const turn = this.getAngleBetweenLines(midpoint, rightNose, noseTip);\r\n\r\n    if (this.options.showDirection) {\r\n      // Draw the direction indicators\r\n      this.drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn);\r\n    }\r\n\r\n    // Calculate distance between nose tip and midpoint, and left and right nose points\r\n    const zDistance = this.getDistanceBetweenPoints(noseTip, midpoint);\r\n    const xDistance = this.getDistanceBetweenPoints(leftNose, rightNose);\r\n\r\n    return { yaw, turn, zDistance, xDistance };\r\n  }\r\n\r\n  /**\r\n   * Draw direction indicators on canvas\r\n   */\r\n  drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn) {\r\n    // Draw the turn angle\r\n    const region2 = new Path2D();\r\n    region2.moveTo(leftNose.x, leftNose.y);\r\n    region2.lineTo(rightNose.x, rightNose.y);\r\n    ctx.strokeStyle = \"blue\";\r\n    ctx.stroke(region2);\r\n    \r\n    // Draw the yaw angle\r\n    const region3 = new Path2D();\r\n    region3.moveTo(midpoint.x, midpoint.y);\r\n    region3.lineTo(noseTip.x, noseTip.y);\r\n    ctx.strokeStyle = \"red\";\r\n    ctx.stroke(region3);\r\n    \r\n    // Draw the perpendicular line\r\n    const region4 = new Path2D();\r\n    region4.moveTo(midpoint.x, midpoint.y);\r\n    region4.lineTo(perpendicularUp.x, perpendicularUp.y);\r\n    ctx.strokeStyle = \"green\";\r\n    ctx.stroke(region4);\r\n    \r\n    // Display the angle values\r\n    ctx.font = \"14px Arial\";\r\n    ctx.fillStyle = \"black\";\r\n    ctx.fillText(`Yaw: ${yaw.toFixed(2)}째`, 10, 20);\r\n    ctx.fillText(`Turn: ${turn.toFixed(2)}째`, 10, 40);\r\n  }\r\n\r\n  /**\r\n   * Calculate distance between two 3D points\r\n   * @param {Object} point1 - First point {x, y, z}\r\n   * @param {Object} point2 - Second point {x, y, z}\r\n   * @returns {number} Distance between points\r\n   */\r\n  getDistanceBetweenPoints(point1, point2) {\r\n    const dx = point1.x - point2.x;\r\n    const dy = point1.y - point2.y;\r\n    const dz = point1.z - point2.z;\r\n    \r\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n  }\r\n\r\n  /**\r\n   * Calculate angle between two lines that share a midpoint\r\n   * @param {Object} midpoint - Shared point {x, y, z}\r\n   * @param {Object} point1 - End of first line {x, y, z}\r\n   * @param {Object} point2 - End of second line {x, y, z}\r\n   * @returns {number} Angle in degrees\r\n   */\r\n  getAngleBetweenLines(midpoint, point1, point2) {\r\n    // Vector 1\r\n    const v1 = {\r\n      x: point1.x - midpoint.x,\r\n      y: point1.y - midpoint.y,\r\n      z: point1.z - midpoint.z\r\n    };\r\n    \r\n    // Vector 2\r\n    const v2 = {\r\n      x: point2.x - midpoint.x,\r\n      y: point2.y - midpoint.y,\r\n      z: point2.z - midpoint.z\r\n    };\r\n    \r\n    // Dot product\r\n    const dotProduct = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\r\n    \r\n    // Magnitudes\r\n    const v1Mag = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);\r\n    const v2Mag = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);\r\n    \r\n    // Angle\r\n    const cosAngle = dotProduct / (v1Mag * v2Mag);\r\n    return Math.acos(Math.min(Math.max(cosAngle, -1), 1)) * (180 / Math.PI);\r\n  }\r\n}\r\n\r\nexport default FaceDirectionDetector; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}