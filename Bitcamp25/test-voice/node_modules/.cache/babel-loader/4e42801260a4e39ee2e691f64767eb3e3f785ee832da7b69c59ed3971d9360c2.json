{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDirectionComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 640,\n  height: 480\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\nfunction FaceDirectionComponent() {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [faceData, setFaceData] = useState({\n    position: {\n      x: 0,\n      y: 0\n    },\n    direction: {\n      yaw: 0,\n      turn: 0\n    }\n  });\n  // Add reference for center position and state for active direction\n  const centerPositionRef = useRef({\n    x: 0,\n    y: 0\n  });\n  const [activeDirection, setActiveDirection] = useState(null);\n  const [isCalibrated, setIsCalibrated] = useState(false);\n  const lastKeySentRef = useRef(null);\n  const keyTimeoutRef = useRef(null);\n  // Add debug state to track keypresses\n  const [debugInfo, setDebugInfo] = useState({\n    keyPressed: null,\n    pressTime: null\n  });\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: false,\n        showTagNumbers: false,\n        showDirection: false\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      if (keyTimeoutRef.current) {\n        clearTimeout(keyTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Function to simulate key press\n  const simulateKeyPress = key => {\n    // Skip if already pressed the same key recently\n    if (lastKeySentRef.current === key) {\n      return;\n    }\n    lastKeySentRef.current = key;\n    setActiveDirection(key);\n\n    // Update debug info\n    setDebugInfo({\n      keyPressed: key,\n      pressTime: new Date().toLocaleTimeString()\n    });\n\n    // Create and dispatch keydown event\n    const keydownEvent = new KeyboardEvent('keydown', {\n      key: key,\n      code: `Key${key.toUpperCase()}`,\n      keyCode: key.charCodeAt(0),\n      which: key.charCodeAt(0),\n      bubbles: true,\n      cancelable: true\n    });\n    document.dispatchEvent(keydownEvent);\n\n    // Also try to trigger the event on window and document.body\n    window.dispatchEvent(keydownEvent);\n    if (document.body) document.body.dispatchEvent(keydownEvent);\n\n    // Log to console for debugging\n    console.log(`Key DOWN: ${key} at ${new Date().toLocaleTimeString()}`);\n\n    // Clear any existing timeout\n    if (keyTimeoutRef.current) {\n      clearTimeout(keyTimeoutRef.current);\n    }\n\n    // Schedule keyup after a 1 second delay\n    keyTimeoutRef.current = setTimeout(() => {\n      // Create and dispatch keyup event\n      const keyupEvent = new KeyboardEvent('keyup', {\n        key: key,\n        code: `Key${key.toUpperCase()}`,\n        keyCode: key.charCodeAt(0),\n        which: key.charCodeAt(0),\n        bubbles: true,\n        cancelable: true\n      });\n      document.dispatchEvent(keyupEvent);\n      window.dispatchEvent(keyupEvent);\n      if (document.body) document.body.dispatchEvent(keyupEvent);\n\n      // Log to console for debugging\n      console.log(`Key UP: ${key} at ${new Date().toLocaleTimeString()}`);\n\n      // Reset the last key sent after a short delay\n      lastKeySentRef.current = null;\n      setActiveDirection(null);\n\n      // Update debug info\n      setDebugInfo(prev => ({\n        ...prev,\n        keyPressed: null\n      }));\n    }, 1000); // Key press duration in ms - changed to 1000ms (1 second)\n  };\n\n  // Function to calibrate center position\n  const calibrateCenter = () => {\n    if (faceData.position.x > 0 && faceData.position.y > 0) {\n      centerPositionRef.current = {\n        ...faceData.position\n      };\n      setIsCalibrated(true);\n    }\n  };\n\n  // Handle video load\n  const handleVideoLoad = async videoNode => {\n    const video = videoNode.target;\n    if (video.readyState !== 4) return;\n    if (loaded) return;\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(webcamRef.current.video, canvasRef.current, data => {\n        // Update face data when detection occurs\n        if (data && data.keypoints && data.keypoints[1]) {\n          const newPosition = {\n            x: Math.round(data.keypoints[1].x),\n            y: Math.round(data.keypoints[1].y)\n          };\n          setFaceData({\n            position: newPosition,\n            direction: {\n              yaw: Math.round(data.yaw || 0),\n              turn: Math.round(data.turn || 0)\n            }\n          });\n\n          // Auto-calibrate on first detection\n          if (!isCalibrated && newPosition.x > 0 && newPosition.y > 0) {\n            calibrateCenter();\n          }\n\n          // Only trigger key presses after calibration\n          if (isCalibrated) {\n            // Calculate movement thresholds (about 15% of the resolution)\n            const thresholdX = inputResolution.width * 0.15;\n            const thresholdY = inputResolution.height * 0.15;\n\n            // Calculate differences from center\n            const diffX = newPosition.x - centerPositionRef.current.x;\n            const diffY = newPosition.y - centerPositionRef.current.y;\n\n            // Determine direction based on strongest movement\n            if (Math.abs(diffX) > Math.abs(diffY)) {\n              // Horizontal movement is stronger\n              if (diffX > thresholdX) {\n                simulateKeyPress('r');\n              } else if (diffX < -thresholdX) {\n                simulateKeyPress('l');\n              }\n            } else {\n              // Vertical movement is stronger\n              if (diffY > thresholdY) {\n                simulateKeyPress('d');\n              } else if (diffY < -thresholdY) {\n                simulateKeyPress('u');\n              }\n            }\n          }\n        }\n      });\n      setLoaded(true);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        visibility: \"hidden\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        width: inputResolution.width,\n        height: inputResolution.height,\n        videoConstraints: videoConstraints,\n        onLoadedData: handleVideoLoad\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        width: inputResolution.width,\n        height: inputResolution.height\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 219,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 210,\n      columnNumber: 7\n    }, this), debugInfo.keyPressed && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate(-50%, -50%)\",\n        backgroundColor: \"rgba(0, 0, 0, 0.8)\",\n        color: \"#00f2fe\",\n        padding: \"20px 40px\",\n        borderRadius: \"12px\",\n        fontFamily: \"monospace\",\n        fontSize: \"48px\",\n        fontWeight: \"bold\",\n        zIndex: 1001,\n        boxShadow: \"0 0 20px rgba(0, 242, 254, 0.5)\",\n        border: \"2px solid #00f2fe\"\n      },\n      children: [\"KEY: \", debugInfo.keyPressed.toUpperCase()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        bottom: \"20px\",\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n        color: \"#00f2fe\",\n        padding: \"8px 16px\",\n        borderRadius: \"8px\",\n        fontFamily: \"monospace\",\n        fontSize: \"14px\",\n        zIndex: 1000,\n        display: \"flex\",\n        gap: \"16px\",\n        flexWrap: \"wrap\",\n        justifyContent: \"center\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Position: x=\", faceData.position.x, \", y=\", faceData.position.y]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 266,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Direction: yaw=\", faceData.direction.yaw, \"\\xB0, turn=\", faceData.direction.turn, \"\\xB0\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 269,\n        columnNumber: 9\n      }, this), isCalibrated ? /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Center: x=\", centerPositionRef.current.x, \", y=\", centerPositionRef.current.y]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 273,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Calibrating center position...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 277,\n        columnNumber: 11\n      }, this), activeDirection && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          backgroundColor: \"#00f2fe\",\n          color: \"black\",\n          padding: \"0px 8px\",\n          borderRadius: \"4px\"\n        },\n        children: [\"Active: \", activeDirection.toUpperCase()]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 280,\n        columnNumber: 11\n      }, this), debugInfo.pressTime && /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Last press: \", debugInfo.pressTime]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 290,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: calibrateCenter,\n        style: {\n          background: \"none\",\n          border: \"1px solid #00f2fe\",\n          color: \"#00f2fe\",\n          padding: \"2px 8px\",\n          borderRadius: \"4px\",\n          cursor: \"pointer\",\n          fontSize: \"12px\"\n        },\n        children: \"Recalibrate\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 294,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 249,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 208,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceDirectionComponent, \"YmU3MeUyLUEi69b1EHh6UyRCO8A=\");\n_c = FaceDirectionComponent;\nexport default FaceDirectionComponent;\nvar _c;\n$RefreshReg$(_c, \"FaceDirectionComponent\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","FaceDirectionComponent","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","faceData","setFaceData","position","x","y","direction","yaw","turn","centerPositionRef","activeDirection","setActiveDirection","isCalibrated","setIsCalibrated","lastKeySentRef","keyTimeoutRef","debugInfo","setDebugInfo","keyPressed","pressTime","initializeDetector","options","showMesh","showTagNumbers","showDirection","faceDetector","stop","current","clearTimeout","simulateKeyPress","key","Date","toLocaleTimeString","keydownEvent","KeyboardEvent","code","toUpperCase","keyCode","charCodeAt","which","bubbles","cancelable","document","dispatchEvent","window","body","console","log","setTimeout","keyupEvent","prev","calibrateCenter","handleVideoLoad","videoNode","video","target","readyState","start","data","keypoints","newPosition","Math","round","thresholdX","thresholdY","diffX","diffY","abs","children","style","visibility","ref","onLoadedData","fileName","_jsxFileName","lineNumber","columnNumber","top","left","transform","backgroundColor","color","padding","borderRadius","fontFamily","fontSize","fontWeight","zIndex","boxShadow","border","bottom","display","gap","flexWrap","justifyContent","onClick","background","cursor","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDirectionComponent.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\r\nimport \"@tensorflow/tfjs\";\r\nimport \"@tensorflow/tfjs-backend-webgl\";\r\nimport \"@mediapipe/face_mesh\";\r\nimport Webcam from \"react-webcam\";\r\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\r\n\r\nconst inputResolution = {\r\n  width: 640,\r\n  height: 480,\r\n};\r\n\r\nconst videoConstraints = {\r\n  width: inputResolution.width,\r\n  height: inputResolution.height,\r\n  facingMode: \"user\",\r\n};\r\n\r\nfunction FaceDirectionComponent() {\r\n  const canvasRef = useRef(null);\r\n  const webcamRef = useRef(null);\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [detector, setDetector] = useState(null);\r\n  const [faceData, setFaceData] = useState({\r\n    position: { x: 0, y: 0 },\r\n    direction: { yaw: 0, turn: 0 }\r\n  });\r\n  // Add reference for center position and state for active direction\r\n  const centerPositionRef = useRef({ x: 0, y: 0 });\r\n  const [activeDirection, setActiveDirection] = useState(null);\r\n  const [isCalibrated, setIsCalibrated] = useState(false);\r\n  const lastKeySentRef = useRef(null);\r\n  const keyTimeoutRef = useRef(null);\r\n  // Add debug state to track keypresses\r\n  const [debugInfo, setDebugInfo] = useState({\r\n    keyPressed: null,\r\n    pressTime: null\r\n  });\r\n\r\n  // Initialize the detector\r\n  useEffect(() => {\r\n    const initializeDetector = async () => {\r\n      const options = {\r\n        showMesh: false,\r\n        showTagNumbers: false,\r\n        showDirection: false\r\n      };\r\n      const faceDetector = new FaceDirectionDetector(options);\r\n      setDetector(faceDetector);\r\n    };\r\n\r\n    initializeDetector();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (detector) {\r\n        detector.stop();\r\n      }\r\n      if (keyTimeoutRef.current) {\r\n        clearTimeout(keyTimeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Function to simulate key press\r\n  const simulateKeyPress = (key) => {\r\n    // Skip if already pressed the same key recently\r\n    if (lastKeySentRef.current === key) {\r\n      return;\r\n    }\r\n\r\n    lastKeySentRef.current = key;\r\n    setActiveDirection(key);\r\n    \r\n    // Update debug info\r\n    setDebugInfo({\r\n      keyPressed: key,\r\n      pressTime: new Date().toLocaleTimeString()\r\n    });\r\n\r\n    // Create and dispatch keydown event\r\n    const keydownEvent = new KeyboardEvent('keydown', {\r\n      key: key,\r\n      code: `Key${key.toUpperCase()}`,\r\n      keyCode: key.charCodeAt(0),\r\n      which: key.charCodeAt(0),\r\n      bubbles: true,\r\n      cancelable: true\r\n    });\r\n    document.dispatchEvent(keydownEvent);\r\n    \r\n    // Also try to trigger the event on window and document.body\r\n    window.dispatchEvent(keydownEvent);\r\n    if (document.body) document.body.dispatchEvent(keydownEvent);\r\n    \r\n    // Log to console for debugging\r\n    console.log(`Key DOWN: ${key} at ${new Date().toLocaleTimeString()}`);\r\n\r\n    // Clear any existing timeout\r\n    if (keyTimeoutRef.current) {\r\n      clearTimeout(keyTimeoutRef.current);\r\n    }\r\n\r\n    // Schedule keyup after a 1 second delay\r\n    keyTimeoutRef.current = setTimeout(() => {\r\n      // Create and dispatch keyup event\r\n      const keyupEvent = new KeyboardEvent('keyup', {\r\n        key: key,\r\n        code: `Key${key.toUpperCase()}`,\r\n        keyCode: key.charCodeAt(0),\r\n        which: key.charCodeAt(0),\r\n        bubbles: true,\r\n        cancelable: true\r\n      });\r\n      document.dispatchEvent(keyupEvent);\r\n      window.dispatchEvent(keyupEvent);\r\n      if (document.body) document.body.dispatchEvent(keyupEvent);\r\n      \r\n      // Log to console for debugging\r\n      console.log(`Key UP: ${key} at ${new Date().toLocaleTimeString()}`);\r\n      \r\n      // Reset the last key sent after a short delay\r\n      lastKeySentRef.current = null;\r\n      setActiveDirection(null);\r\n      \r\n      // Update debug info\r\n      setDebugInfo(prev => ({\r\n        ...prev,\r\n        keyPressed: null\r\n      }));\r\n    }, 1000); // Key press duration in ms - changed to 1000ms (1 second)\r\n  };\r\n\r\n  // Function to calibrate center position\r\n  const calibrateCenter = () => {\r\n    if (faceData.position.x > 0 && faceData.position.y > 0) {\r\n      centerPositionRef.current = { ...faceData.position };\r\n      setIsCalibrated(true);\r\n    }\r\n  };\r\n\r\n  // Handle video load\r\n  const handleVideoLoad = async (videoNode) => {\r\n    const video = videoNode.target;\r\n    if (video.readyState !== 4) return;\r\n    if (loaded) return;\r\n\r\n    if (detector && webcamRef.current && canvasRef.current) {\r\n      await detector.start(\r\n        webcamRef.current.video, \r\n        canvasRef.current, \r\n        (data) => {\r\n          // Update face data when detection occurs\r\n          if (data && data.keypoints && data.keypoints[1]) {\r\n            const newPosition = {\r\n              x: Math.round(data.keypoints[1].x),\r\n              y: Math.round(data.keypoints[1].y)\r\n            };\r\n            \r\n            setFaceData({\r\n              position: newPosition,\r\n              direction: {\r\n                yaw: Math.round(data.yaw || 0),\r\n                turn: Math.round(data.turn || 0)\r\n              }\r\n            });\r\n\r\n            // Auto-calibrate on first detection\r\n            if (!isCalibrated && newPosition.x > 0 && newPosition.y > 0) {\r\n              calibrateCenter();\r\n            }\r\n\r\n            // Only trigger key presses after calibration\r\n            if (isCalibrated) {\r\n              // Calculate movement thresholds (about 15% of the resolution)\r\n              const thresholdX = inputResolution.width * 0.15;\r\n              const thresholdY = inputResolution.height * 0.15;\r\n              \r\n              // Calculate differences from center\r\n              const diffX = newPosition.x - centerPositionRef.current.x;\r\n              const diffY = newPosition.y - centerPositionRef.current.y;\r\n              \r\n              // Determine direction based on strongest movement\r\n              if (Math.abs(diffX) > Math.abs(diffY)) {\r\n                // Horizontal movement is stronger\r\n                if (diffX > thresholdX) {\r\n                  simulateKeyPress('r');\r\n                } else if (diffX < -thresholdX) {\r\n                  simulateKeyPress('l');\r\n                }\r\n              } else {\r\n                // Vertical movement is stronger\r\n                if (diffY > thresholdY) {\r\n                  simulateKeyPress('d');\r\n                } else if (diffY < -thresholdY) {\r\n                  simulateKeyPress('u');\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      );\r\n      setLoaded(true);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* Hidden webcam and canvas for detection */}\r\n      <div style={{ position: \"absolute\", visibility: \"hidden\" }}>\r\n        <Webcam\r\n          ref={webcamRef}\r\n          width={inputResolution.width}\r\n          height={inputResolution.height}\r\n          videoConstraints={videoConstraints}\r\n          onLoadedData={handleVideoLoad}\r\n        />\r\n        \r\n        <canvas\r\n          ref={canvasRef}\r\n          width={inputResolution.width}\r\n          height={inputResolution.height}\r\n        />\r\n      </div>\r\n\r\n      {/* Debug display - large key indicator */}\r\n      {debugInfo.keyPressed && (\r\n        <div style={{\r\n          position: \"fixed\",\r\n          top: \"50%\",\r\n          left: \"50%\",\r\n          transform: \"translate(-50%, -50%)\",\r\n          backgroundColor: \"rgba(0, 0, 0, 0.8)\",\r\n          color: \"#00f2fe\",\r\n          padding: \"20px 40px\",\r\n          borderRadius: \"12px\",\r\n          fontFamily: \"monospace\",\r\n          fontSize: \"48px\",\r\n          fontWeight: \"bold\",\r\n          zIndex: 1001,\r\n          boxShadow: \"0 0 20px rgba(0, 242, 254, 0.5)\",\r\n          border: \"2px solid #00f2fe\"\r\n        }}>\r\n          KEY: {debugInfo.keyPressed.toUpperCase()}\r\n        </div>\r\n      )}\r\n\r\n      {/* Simple display of face data */}\r\n      <div style={{ \r\n        position: \"fixed\", \r\n        bottom: \"20px\",\r\n        left: \"50%\",\r\n        transform: \"translateX(-50%)\",\r\n        backgroundColor: \"rgba(0, 0, 0, 0.7)\",\r\n        color: \"#00f2fe\",\r\n        padding: \"8px 16px\",\r\n        borderRadius: \"8px\",\r\n        fontFamily: \"monospace\",\r\n        fontSize: \"14px\",\r\n        zIndex: 1000,\r\n        display: \"flex\",\r\n        gap: \"16px\",\r\n        flexWrap: \"wrap\",\r\n        justifyContent: \"center\"\r\n      }}>\r\n        <div>\r\n          Position: x={faceData.position.x}, y={faceData.position.y}\r\n        </div>\r\n        <div>\r\n          Direction: yaw={faceData.direction.yaw}°, turn={faceData.direction.turn}°\r\n        </div>\r\n        {isCalibrated ? (\r\n          <div>\r\n            Center: x={centerPositionRef.current.x}, y={centerPositionRef.current.y}\r\n          </div>\r\n        ) : (\r\n          <div>Calibrating center position...</div>\r\n        )}\r\n        {activeDirection && (\r\n          <div style={{ \r\n            backgroundColor: \"#00f2fe\", \r\n            color: \"black\", \r\n            padding: \"0px 8px\", \r\n            borderRadius: \"4px\" \r\n          }}>\r\n            Active: {activeDirection.toUpperCase()}\r\n          </div>\r\n        )}\r\n        {debugInfo.pressTime && (\r\n          <div>\r\n            Last press: {debugInfo.pressTime}\r\n          </div>\r\n        )}\r\n        <button \r\n          onClick={calibrateCenter}\r\n          style={{\r\n            background: \"none\",\r\n            border: \"1px solid #00f2fe\",\r\n            color: \"#00f2fe\",\r\n            padding: \"2px 8px\",\r\n            borderRadius: \"4px\",\r\n            cursor: \"pointer\",\r\n            fontSize: \"12px\"\r\n          }}\r\n        >\r\n          Recalibrate\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FaceDirectionComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}