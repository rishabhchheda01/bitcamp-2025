{"ast":null,"code":"import * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport { TRIANGULATION } from \"./triangulation\";\n\n/**\r\n * FaceDirectionDetector class\r\n * A reusable class for detecting face landmarks and calculating face direction\r\n */\nclass FaceDirectionDetector {\n  constructor(options = {}) {\n    // Default options\n    this.options = {\n      runtime: \"tfjs\",\n      showMesh: true,\n      showTagNumbers: false,\n      showDirection: true,\n      drawDelay: 300,\n      // ms\n      ...options\n    };\n    this.detector = null;\n    this.canvas = null;\n    this.video = null;\n    this.isRunning = false;\n    this.animationId = null;\n  }\n\n  /**\r\n   * Initialize the detector\r\n   * @returns {Promise<void>}\r\n   */\n  async initialize() {\n    const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\n    const detectorConfig = {\n      runtime: this.options.runtime\n    };\n    this.detector = await faceLandmarksDetection.createDetector(model, detectorConfig);\n  }\n\n  /**\r\n   * Start the face direction detection process\r\n   * @param {HTMLVideoElement} video - Video element to detect faces from\r\n   * @param {HTMLCanvasElement} canvas - Canvas element to draw on\r\n   * @param {Function} callback - Callback function to receive direction data\r\n   * @returns {Promise<void>}\r\n   */\n  async start(video, canvas, callback) {\n    if (!this.detector) {\n      await this.initialize();\n    }\n    this.video = video;\n    this.canvas = canvas;\n    this.callback = callback;\n    this.isRunning = true;\n    this.detect();\n  }\n\n  /**\r\n   * Stop the detection process\r\n   */\n  stop() {\n    this.isRunning = false;\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n\n  /**\r\n   * Set options for the detector\r\n   * @param {Object} options - Options to set\r\n   */\n  setOptions(options) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n  }\n\n  /**\r\n   * Main detection loop\r\n   */\n  async detect() {\n    if (!this.isRunning) return;\n    const estimationConfig = {\n      flipHorizontal: true\n    };\n    const faces = await this.detector.estimateFaces(this.video, estimationConfig);\n    const ctx = this.canvas.getContext(\"2d\");\n    setTimeout(() => {\n      this.animationId = requestAnimationFrame(() => {\n        if (faces && faces.length > 0) {\n          const angle = this.drawMesh(faces[0], ctx);\n          if (this.callback) {\n            this.callback(angle);\n          }\n        }\n        if (this.isRunning) {\n          this.detect();\n        }\n      });\n    }, this.options.drawDelay);\n  }\n\n  /**\r\n   * Draw the face mesh on canvas and calculate direction\r\n   * @param {Object} prediction - Face prediction data\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @returns {Object} Direction data\r\n   */\n  drawMesh(prediction, ctx) {\n    if (!prediction) return;\n    const keyPoints = prediction.keypoints;\n    if (!keyPoints || keyPoints.length === 0) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Draw and calculate\n    this.drawFaceMesh(ctx, keyPoints);\n    return this.calculateDirection(ctx, keyPoints);\n  }\n\n  /**\r\n   * Draw face mesh on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   */\n  drawFaceMesh(ctx, keyPoints) {\n    if (this.options.showMesh) {\n      this.drawMeshPaths(keyPoints, ctx);\n    }\n    if (this.options.showTagNumbers) {\n      let index = 0;\n      for (let keyPoint of keyPoints) {\n        ctx.beginPath();\n        ctx.arc(keyPoint.x, keyPoint.y, 1, 0, 3 * Math.PI);\n        ctx.fillText(index, keyPoint.x, keyPoint.y);\n        ctx.fillStyle = \"black\";\n        ctx.fill();\n        index++;\n      }\n    }\n  }\n\n  /**\r\n   * Draw mesh paths on canvas\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   */\n  drawMeshPaths(keyPoints, ctx) {\n    for (let i = 0; i < TRIANGULATION.length / 3; i++) {\n      const points = [TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1], TRIANGULATION[i * 3 + 2]].map(index => keyPoints[index]);\n      this.drawPath(ctx, points, true);\n    }\n  }\n\n  /**\r\n   * Draw a path on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} points - Points to draw\r\n   * @param {boolean} closePath - Whether to close the path\r\n   */\n  drawPath(ctx, points, closePath) {\n    const region = new Path2D();\n    region.moveTo(points[0].x, points[0].y);\n    for (let i = 1; i < points.length; i++) {\n      const point = points[i];\n      region.lineTo(point.x, point.y);\n    }\n    if (closePath) {\n      region.closePath();\n    }\n    ctx.strokeStyle = \"black\";\n    ctx.stroke(region);\n  }\n\n  /**\r\n   * Calculate face direction based on keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @returns {Object} Direction data\r\n   */\n  calculateDirection(ctx, keyPoints) {\n    let noseTip, leftNose, rightNose;\n    try {\n      noseTip = {\n        ...keyPoints[1],\n        name: \"nose tip\"\n      };\n      leftNose = {\n        ...keyPoints[279],\n        name: \"left nose\"\n      };\n      rightNose = {\n        ...keyPoints[49],\n        name: \"right nose\"\n      };\n    } catch (error) {\n      console.log(\"Error creating directional points\", keyPoints, error);\n      return null;\n    }\n\n    // Midsection of nose is back of nose perpendicular\n    const midpoint = {\n      x: (leftNose.x + rightNose.x) / 2,\n      y: (leftNose.y + rightNose.y) / 2,\n      z: (leftNose.z + rightNose.z) / 2\n    };\n    const perpendicularUp = {\n      x: midpoint.x,\n      y: midpoint.y - 50,\n      z: midpoint.z\n    };\n\n    // Calculate angles\n    const yaw = this.getAngleBetweenLines(midpoint, noseTip, perpendicularUp);\n    const turn = this.getAngleBetweenLines(midpoint, rightNose, noseTip);\n    if (this.options.showDirection) {\n      // Draw the direction indicators\n      this.drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn);\n    }\n\n    // Calculate distance between nose tip and midpoint, and left and right nose points\n    const zDistance = this.getDistanceBetweenPoints(noseTip, midpoint);\n    const xDistance = this.getDistanceBetweenPoints(leftNose, rightNose);\n    return {\n      yaw,\n      turn,\n      zDistance,\n      xDistance\n    };\n  }\n\n  /**\r\n   * Draw direction indicators on canvas\r\n   */\n  drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn) {\n    // Draw the turn angle\n    const region2 = new Path2D();\n    region2.moveTo(leftNose.x, leftNose.y);\n    region2.lineTo(noseTip.x, noseTip.y);\n    region2.lineTo(rightNose.x, rightNose.y);\n    region2.lineTo(midpoint.x, midpoint.y);\n    region2.lineTo(leftNose.x, leftNose.y);\n    region2.closePath();\n    ctx.fillStyle = \"brown\";\n    ctx.stroke(region2);\n    ctx.fillText(Math.trunc(turn) + \"째\", rightNose.x + 10, rightNose.y);\n    ctx.fill(region2);\n\n    // Draw the yaw angle\n    const region = new Path2D();\n    region.moveTo(midpoint.x, midpoint.y);\n    region.lineTo(perpendicularUp.x, perpendicularUp.y);\n    region.lineTo(noseTip.x, noseTip.y);\n    region.lineTo(midpoint.x, midpoint.y);\n    region.closePath();\n    ctx.fillStyle = \"red\";\n    ctx.stroke(region);\n    ctx.fillText(Math.trunc(yaw) + \"째\", midpoint.x + 10, midpoint.y);\n    ctx.fill(region);\n  }\n\n  /**\r\n   * Calculate distance between two points\r\n   * @param {Object} point1 - First point\r\n   * @param {Object} point2 - Second point\r\n   * @returns {number} Distance\r\n   */\n  getDistanceBetweenPoints(point1, point2) {\n    const xDistance = point1.x - point2.x;\n    const yDistance = point1.y - point2.y;\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n  }\n\n  /**\r\n   * Calculate angle between two lines with common midpoint\r\n   * @param {Object} midpoint - Common point of both lines\r\n   * @param {Object} point1 - End point of first line\r\n   * @param {Object} point2 - End point of second line\r\n   * @returns {number} Angle in degrees\r\n   */\n  getAngleBetweenLines(midpoint, point1, point2) {\n    const vector1 = {\n      x: point1.x - midpoint.x,\n      y: point1.y - midpoint.y\n    };\n    const vector2 = {\n      x: point2.x - midpoint.x,\n      y: point2.y - midpoint.y\n    };\n\n    // Calculate the dot product of the two vectors\n    const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;\n\n    // Calculate the magnitudes of the vectors\n    const magnitude1 = Math.sqrt(vector1.x * vector1.x + vector1.y * vector1.y);\n    const magnitude2 = Math.sqrt(vector2.x * vector2.x + vector2.y * vector2.y);\n\n    // Calculate the cosine of the angle between the two vectors\n    const cosineTheta = dotProduct / (magnitude1 * magnitude2);\n\n    // Use the arccosine function to get the angle in radians\n    const angleInRadians = Math.acos(cosineTheta);\n\n    // Convert the angle to degrees\n    const angleInDegrees = angleInRadians * 180 / Math.PI;\n    return angleInDegrees;\n  }\n}\nexport default FaceDirectionDetector;","map":{"version":3,"names":["faceLandmarksDetection","TRIANGULATION","FaceDirectionDetector","constructor","options","runtime","showMesh","showTagNumbers","showDirection","drawDelay","detector","canvas","video","isRunning","animationId","initialize","model","SupportedModels","MediaPipeFaceMesh","detectorConfig","createDetector","start","callback","detect","stop","cancelAnimationFrame","setOptions","estimationConfig","flipHorizontal","faces","estimateFaces","ctx","getContext","setTimeout","requestAnimationFrame","length","angle","drawMesh","prediction","keyPoints","keypoints","clearRect","width","height","drawFaceMesh","calculateDirection","drawMeshPaths","index","keyPoint","beginPath","arc","x","y","Math","PI","fillText","fillStyle","fill","i","points","map","drawPath","closePath","region","Path2D","moveTo","point","lineTo","strokeStyle","stroke","noseTip","leftNose","rightNose","name","error","console","log","midpoint","z","perpendicularUp","yaw","getAngleBetweenLines","turn","drawDirectionIndicators","zDistance","getDistanceBetweenPoints","xDistance","region2","trunc","point1","point2","yDistance","sqrt","vector1","vector2","dotProduct","magnitude1","magnitude2","cosineTheta","angleInRadians","acos","angleInDegrees"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/simple/FaceDirectionDetector.js"],"sourcesContent":["import * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\r\nimport { TRIANGULATION } from \"./triangulation\";\r\n\r\n/**\r\n * FaceDirectionDetector class\r\n * A reusable class for detecting face landmarks and calculating face direction\r\n */\r\nclass FaceDirectionDetector {\r\n  constructor(options = {}) {\r\n    // Default options\r\n    this.options = {\r\n      runtime: \"tfjs\",\r\n      showMesh: true,\r\n      showTagNumbers: false,\r\n      showDirection: true,\r\n      drawDelay: 300, // ms\r\n      ...options\r\n    };\r\n    \r\n    this.detector = null;\r\n    this.canvas = null;\r\n    this.video = null;\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize the detector\r\n   * @returns {Promise<void>}\r\n   */\r\n  async initialize() {\r\n    const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\r\n    const detectorConfig = {\r\n      runtime: this.options.runtime,\r\n    };\r\n    \r\n    this.detector = await faceLandmarksDetection.createDetector(\r\n      model,\r\n      detectorConfig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Start the face direction detection process\r\n   * @param {HTMLVideoElement} video - Video element to detect faces from\r\n   * @param {HTMLCanvasElement} canvas - Canvas element to draw on\r\n   * @param {Function} callback - Callback function to receive direction data\r\n   * @returns {Promise<void>}\r\n   */\r\n  async start(video, canvas, callback) {\r\n    if (!this.detector) {\r\n      await this.initialize();\r\n    }\r\n    \r\n    this.video = video;\r\n    this.canvas = canvas;\r\n    this.callback = callback;\r\n    this.isRunning = true;\r\n    \r\n    this.detect();\r\n  }\r\n\r\n  /**\r\n   * Stop the detection process\r\n   */\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n      this.animationId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set options for the detector\r\n   * @param {Object} options - Options to set\r\n   */\r\n  setOptions(options) {\r\n    this.options = {\r\n      ...this.options,\r\n      ...options\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Main detection loop\r\n   */\r\n  async detect() {\r\n    if (!this.isRunning) return;\r\n    \r\n    const estimationConfig = { flipHorizontal: true };\r\n    const faces = await this.detector.estimateFaces(this.video, estimationConfig);\r\n    const ctx = this.canvas.getContext(\"2d\");\r\n    \r\n    setTimeout(() => {\r\n      this.animationId = requestAnimationFrame(() => {\r\n        if (faces && faces.length > 0) {\r\n          const angle = this.drawMesh(faces[0], ctx);\r\n          if (this.callback) {\r\n            this.callback(angle);\r\n          }\r\n        }\r\n        \r\n        if (this.isRunning) {\r\n          this.detect();\r\n        }\r\n      });\r\n    }, this.options.drawDelay);\r\n  }\r\n\r\n  /**\r\n   * Draw the face mesh on canvas and calculate direction\r\n   * @param {Object} prediction - Face prediction data\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @returns {Object} Direction data\r\n   */\r\n  drawMesh(prediction, ctx) {\r\n    if (!prediction) return;\r\n    const keyPoints = prediction.keypoints;\r\n    if (!keyPoints || keyPoints.length === 0) return;\r\n\r\n    // Clear canvas\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw and calculate\r\n    this.drawFaceMesh(ctx, keyPoints);\r\n    return this.calculateDirection(ctx, keyPoints);\r\n  }\r\n\r\n  /**\r\n   * Draw face mesh on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   */\r\n  drawFaceMesh(ctx, keyPoints) {\r\n    if (this.options.showMesh) {\r\n      this.drawMeshPaths(keyPoints, ctx);\r\n    }\r\n    \r\n    if (this.options.showTagNumbers) {\r\n      let index = 0;\r\n      for (let keyPoint of keyPoints) {\r\n        ctx.beginPath();\r\n        ctx.arc(keyPoint.x, keyPoint.y, 1, 0, 3 * Math.PI);\r\n        ctx.fillText(index, keyPoint.x, keyPoint.y);\r\n        ctx.fillStyle = \"black\";\r\n        ctx.fill();\r\n        index++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw mesh paths on canvas\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   */\r\n  drawMeshPaths(keyPoints, ctx) {\r\n    for (let i = 0; i < TRIANGULATION.length / 3; i++) {\r\n      const points = [\r\n        TRIANGULATION[i * 3],\r\n        TRIANGULATION[i * 3 + 1],\r\n        TRIANGULATION[i * 3 + 2],\r\n      ].map((index) => keyPoints[index]);\r\n      \r\n      this.drawPath(ctx, points, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw a path on canvas\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} points - Points to draw\r\n   * @param {boolean} closePath - Whether to close the path\r\n   */\r\n  drawPath(ctx, points, closePath) {\r\n    const region = new Path2D();\r\n    region.moveTo(points[0].x, points[0].y);\r\n    \r\n    for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      region.lineTo(point.x, point.y);\r\n    }\r\n    \r\n    if (closePath) {\r\n      region.closePath();\r\n    }\r\n    \r\n    ctx.strokeStyle = \"black\";\r\n    ctx.stroke(region);\r\n  }\r\n\r\n  /**\r\n   * Calculate face direction based on keypoints\r\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\r\n   * @param {Array} keyPoints - Face keypoints\r\n   * @returns {Object} Direction data\r\n   */\r\n  calculateDirection(ctx, keyPoints) {\r\n    let noseTip, leftNose, rightNose;\r\n    \r\n    try {\r\n      noseTip = { ...keyPoints[1], name: \"nose tip\" };\r\n      leftNose = { ...keyPoints[279], name: \"left nose\" };\r\n      rightNose = { ...keyPoints[49], name: \"right nose\" };\r\n    } catch (error) {\r\n      console.log(\"Error creating directional points\", keyPoints, error);\r\n      return null;\r\n    }\r\n\r\n    // Midsection of nose is back of nose perpendicular\r\n    const midpoint = {\r\n      x: (leftNose.x + rightNose.x) / 2,\r\n      y: (leftNose.y + rightNose.y) / 2,\r\n      z: (leftNose.z + rightNose.z) / 2,\r\n    };\r\n    \r\n    const perpendicularUp = { \r\n      x: midpoint.x, \r\n      y: midpoint.y - 50, \r\n      z: midpoint.z \r\n    };\r\n\r\n    // Calculate angles\r\n    const yaw = this.getAngleBetweenLines(midpoint, noseTip, perpendicularUp);\r\n    const turn = this.getAngleBetweenLines(midpoint, rightNose, noseTip);\r\n\r\n    if (this.options.showDirection) {\r\n      // Draw the direction indicators\r\n      this.drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn);\r\n    }\r\n\r\n    // Calculate distance between nose tip and midpoint, and left and right nose points\r\n    const zDistance = this.getDistanceBetweenPoints(noseTip, midpoint);\r\n    const xDistance = this.getDistanceBetweenPoints(leftNose, rightNose);\r\n\r\n    return { yaw, turn, zDistance, xDistance };\r\n  }\r\n\r\n  /**\r\n   * Draw direction indicators on canvas\r\n   */\r\n  drawDirectionIndicators(ctx, noseTip, leftNose, rightNose, midpoint, perpendicularUp, yaw, turn) {\r\n    // Draw the turn angle\r\n    const region2 = new Path2D();\r\n    region2.moveTo(leftNose.x, leftNose.y);\r\n    region2.lineTo(noseTip.x, noseTip.y);\r\n    region2.lineTo(rightNose.x, rightNose.y);\r\n    region2.lineTo(midpoint.x, midpoint.y);\r\n    region2.lineTo(leftNose.x, leftNose.y);\r\n    region2.closePath();\r\n    ctx.fillStyle = \"brown\";\r\n    ctx.stroke(region2);\r\n    ctx.fillText(Math.trunc(turn) + \"째\", rightNose.x + 10, rightNose.y);\r\n    ctx.fill(region2);\r\n\r\n    // Draw the yaw angle\r\n    const region = new Path2D();\r\n    region.moveTo(midpoint.x, midpoint.y);\r\n    region.lineTo(perpendicularUp.x, perpendicularUp.y);\r\n    region.lineTo(noseTip.x, noseTip.y);\r\n    region.lineTo(midpoint.x, midpoint.y);\r\n    region.closePath();\r\n    ctx.fillStyle = \"red\";\r\n    ctx.stroke(region);\r\n    ctx.fillText(Math.trunc(yaw) + \"째\", midpoint.x + 10, midpoint.y);\r\n    ctx.fill(region);\r\n  }\r\n\r\n  /**\r\n   * Calculate distance between two points\r\n   * @param {Object} point1 - First point\r\n   * @param {Object} point2 - Second point\r\n   * @returns {number} Distance\r\n   */\r\n  getDistanceBetweenPoints(point1, point2) {\r\n    const xDistance = point1.x - point2.x;\r\n    const yDistance = point1.y - point2.y;\r\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\r\n  }\r\n\r\n  /**\r\n   * Calculate angle between two lines with common midpoint\r\n   * @param {Object} midpoint - Common point of both lines\r\n   * @param {Object} point1 - End point of first line\r\n   * @param {Object} point2 - End point of second line\r\n   * @returns {number} Angle in degrees\r\n   */\r\n  getAngleBetweenLines(midpoint, point1, point2) {\r\n    const vector1 = { x: point1.x - midpoint.x, y: point1.y - midpoint.y };\r\n    const vector2 = { x: point2.x - midpoint.x, y: point2.y - midpoint.y };\r\n\r\n    // Calculate the dot product of the two vectors\r\n    const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;\r\n\r\n    // Calculate the magnitudes of the vectors\r\n    const magnitude1 = Math.sqrt(vector1.x * vector1.x + vector1.y * vector1.y);\r\n    const magnitude2 = Math.sqrt(vector2.x * vector2.x + vector2.y * vector2.y);\r\n\r\n    // Calculate the cosine of the angle between the two vectors\r\n    const cosineTheta = dotProduct / (magnitude1 * magnitude2);\r\n\r\n    // Use the arccosine function to get the angle in radians\r\n    const angleInRadians = Math.acos(cosineTheta);\r\n\r\n    // Convert the angle to degrees\r\n    const angleInDegrees = (angleInRadians * 180) / Math.PI;\r\n\r\n    return angleInDegrees;\r\n  }\r\n}\r\n\r\nexport default FaceDirectionDetector; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}