{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceCameraControl.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./simple/FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 320,\n  // Smaller resolution for better performance\n  height: 240\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\nfunction FaceCameraControl({\n  onFaceDirectionChange,\n  enabled = true,\n  showDebug = false\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [directionData, setDirectionData] = useState(null);\n  const animationFrameRef = useRef(null);\n  const lastDirectionRef = useRef({\n    horizontal: 'center',\n    vertical: 'center'\n  });\n  const lastKeyPressRef = useRef(null);\n  const keyThrottleRef = useRef(false);\n  // Add debugging state\n  const [directionCounts, setDirectionCounts] = useState({\n    left: 0,\n    right: 0,\n    up: 0,\n    down: 0,\n    center: 0\n  });\n\n  // Initialize the detector\n  useEffect(() => {\n    if (!enabled) return;\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: showDebug,\n        showTagNumbers: false,\n        showDirection: showDebug,\n        drawDelay: 100 // Faster updates for more responsive controls\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [enabled, showDebug]);\n\n  // Handle video load\n  const handleVideoLoad = async videoNode => {\n    const video = videoNode.target;\n    if (video.readyState !== 4 || !enabled) return;\n    if (loaded) return;\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(webcamRef.current.video, canvasRef.current, handleDirectionData);\n      setLoaded(true);\n    }\n  };\n\n  // Process face direction data and convert to key presses\n  const handleDirectionData = data => {\n    if (!data || !enabled) return;\n    setDirectionData(data);\n\n    // Calculate horizontal position (yaw indicates left/right)\n    // FIXED: Correct interpretation of yaw values\n    // negative yaw (< 0) = looking left (from camera's perspective)\n    // positive yaw (> 0) = looking right (from camera's perspective)\n    let horizontalPosition = 'center';\n    if (data.yaw < -15) {\n      horizontalPosition = 'left'; // Looking left from camera perspective\n    } else if (data.yaw > 15) {\n      horizontalPosition = 'right'; // Looking right from camera perspective\n    }\n\n    // Calculate vertical position using turn angle\n    // FIXED: Correct interpretation of turn values\n    // positive turn (> 0) = looking up\n    // negative turn (< 0) = looking down\n    let verticalPosition = 'center';\n    if (data.turn < -15) {\n      verticalPosition = 'down';\n    } else if (data.turn > 15) {\n      verticalPosition = 'up';\n    }\n\n    // Update counts for debugging\n    setDirectionCounts(prev => ({\n      ...prev,\n      [horizontalPosition]: prev[horizontalPosition] + 1,\n      [verticalPosition]: prev[verticalPosition] + 1\n    }));\n\n    // Determine if direction has changed\n    const direction = {\n      horizontal: horizontalPosition,\n      vertical: verticalPosition\n    };\n    const hasChanged = direction.horizontal !== lastDirectionRef.current.horizontal || direction.vertical !== lastDirectionRef.current.vertical;\n\n    // Update the last direction\n    lastDirectionRef.current = direction;\n\n    // Only send direction change if it has changed and not throttled\n    if (hasChanged && !keyThrottleRef.current) {\n      keyThrottleRef.current = true;\n\n      // Call the callback with appropriate key\n      let key = null;\n      if (direction.horizontal === 'left') key = 'l';else if (direction.horizontal === 'right') key = 'r';else if (direction.vertical === 'up') key = 'u';else if (direction.vertical === 'down') key = 'd';\n      if (key && key !== lastKeyPressRef.current) {\n        lastKeyPressRef.current = key;\n        if (onFaceDirectionChange) {\n          onFaceDirectionChange(key, direction);\n        }\n      }\n\n      // Reset throttle after delay\n      setTimeout(() => {\n        keyThrottleRef.current = false;\n      }, 300); // 300ms throttle to prevent too many rapid direction changes\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `face-camera-control ${!enabled ? 'disabled' : ''}`,\n    style: {\n      position: 'relative',\n      width: showDebug ? inputResolution.width : '100px',\n      height: showDebug ? inputResolution.height : '100px'\n    },\n    children: [!loaded && enabled && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"loading\",\n      children: \"Loading face detection...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 150,\n      columnNumber: 30\n    }, this), /*#__PURE__*/_jsxDEV(Webcam, {\n      ref: webcamRef,\n      width: inputResolution.width,\n      height: inputResolution.height,\n      style: {\n        visibility: showDebug ? 'hidden' : 'visible',\n        position: showDebug ? 'absolute' : 'relative',\n        borderRadius: '50%',\n        objectFit: 'cover',\n        width: showDebug ? '100%' : '100px',\n        height: showDebug ? '100%' : '100px'\n      },\n      videoConstraints: videoConstraints,\n      onLoadedData: handleVideoLoad\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: inputResolution.width,\n      height: inputResolution.height,\n      style: {\n        display: showDebug ? 'block' : 'none',\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        border: '1px solid black'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }, this), showDebug && directionData && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"data-display\",\n      style: {\n        position: 'absolute',\n        bottom: '-180px',\n        left: 0,\n        background: 'rgba(255,255,255,0.8)',\n        padding: '5px'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Face Direction:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        children: JSON.stringify({\n          direction: lastDirectionRef.current,\n          yaw: Math.round(directionData.yaw),\n          turn: Math.round(directionData.turn)\n        }, null, 2)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 184,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          marginTop: '10px',\n          fontSize: '12px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"Direction counts:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 190,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n          children: JSON.stringify(directionCounts, null, 2)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 191,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 189,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 182,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceCameraControl, \"bphIifDReZfHXKNIHrzkU03TUd4=\");\n_c = FaceCameraControl;\nexport default FaceCameraControl;\nvar _c;\n$RefreshReg$(_c, \"FaceCameraControl\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","FaceCameraControl","onFaceDirectionChange","enabled","showDebug","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","directionData","setDirectionData","animationFrameRef","lastDirectionRef","horizontal","vertical","lastKeyPressRef","keyThrottleRef","directionCounts","setDirectionCounts","left","right","up","down","center","initializeDetector","options","showMesh","showTagNumbers","showDirection","drawDelay","faceDetector","stop","current","cancelAnimationFrame","handleVideoLoad","videoNode","video","target","readyState","start","handleDirectionData","data","horizontalPosition","yaw","verticalPosition","turn","prev","direction","hasChanged","key","setTimeout","className","style","position","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","visibility","borderRadius","objectFit","onLoadedData","display","top","border","bottom","background","padding","JSON","stringify","Math","round","marginTop","fontSize","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceCameraControl.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\r\nimport \"@tensorflow/tfjs\";\r\nimport \"@tensorflow/tfjs-backend-webgl\";\r\nimport \"@mediapipe/face_mesh\";\r\nimport Webcam from \"react-webcam\";\r\nimport FaceDirectionDetector from \"./simple/FaceDirectionDetector\";\r\n\r\nconst inputResolution = {\r\n  width: 320,  // Smaller resolution for better performance\r\n  height: 240,\r\n};\r\n\r\nconst videoConstraints = {\r\n  width: inputResolution.width,\r\n  height: inputResolution.height,\r\n  facingMode: \"user\",\r\n};\r\n\r\nfunction FaceCameraControl({ onFaceDirectionChange, enabled = true, showDebug = false }) {\r\n  const canvasRef = useRef(null);\r\n  const webcamRef = useRef(null);\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [detector, setDetector] = useState(null);\r\n  const [directionData, setDirectionData] = useState(null);\r\n  const animationFrameRef = useRef(null);\r\n  const lastDirectionRef = useRef({ horizontal: 'center', vertical: 'center' });\r\n  const lastKeyPressRef = useRef(null);\r\n  const keyThrottleRef = useRef(false);\r\n  // Add debugging state\r\n  const [directionCounts, setDirectionCounts] = useState({\r\n    left: 0, right: 0, up: 0, down: 0, center: 0\r\n  });\r\n\r\n  // Initialize the detector\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const initializeDetector = async () => {\r\n      const options = {\r\n        showMesh: showDebug,\r\n        showTagNumbers: false,\r\n        showDirection: showDebug,\r\n        drawDelay: 100  // Faster updates for more responsive controls\r\n      };\r\n      \r\n      const faceDetector = new FaceDirectionDetector(options);\r\n      setDetector(faceDetector);\r\n    };\r\n\r\n    initializeDetector();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (detector) {\r\n        detector.stop();\r\n      }\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [enabled, showDebug]);\r\n\r\n  // Handle video load\r\n  const handleVideoLoad = async (videoNode) => {\r\n    const video = videoNode.target;\r\n    if (video.readyState !== 4 || !enabled) return;\r\n    if (loaded) return;\r\n\r\n    if (detector && webcamRef.current && canvasRef.current) {\r\n      await detector.start(\r\n        webcamRef.current.video, \r\n        canvasRef.current, \r\n        handleDirectionData\r\n      );\r\n      setLoaded(true);\r\n    }\r\n  };\r\n\r\n  // Process face direction data and convert to key presses\r\n  const handleDirectionData = (data) => {\r\n    if (!data || !enabled) return;\r\n    \r\n    setDirectionData(data);\r\n    \r\n    // Calculate horizontal position (yaw indicates left/right)\r\n    // FIXED: Correct interpretation of yaw values\r\n    // negative yaw (< 0) = looking left (from camera's perspective)\r\n    // positive yaw (> 0) = looking right (from camera's perspective)\r\n    let horizontalPosition = 'center';\r\n    if (data.yaw < -15) {\r\n      horizontalPosition = 'left';  // Looking left from camera perspective\r\n    } else if (data.yaw > 15) {\r\n      horizontalPosition = 'right'; // Looking right from camera perspective\r\n    }\r\n    \r\n    // Calculate vertical position using turn angle\r\n    // FIXED: Correct interpretation of turn values\r\n    // positive turn (> 0) = looking up\r\n    // negative turn (< 0) = looking down\r\n    let verticalPosition = 'center';\r\n    if (data.turn < -15) {\r\n      verticalPosition = 'down';\r\n    } else if (data.turn > 15) {\r\n      verticalPosition = 'up';\r\n    }\r\n    \r\n    // Update counts for debugging\r\n    setDirectionCounts(prev => ({\r\n      ...prev,\r\n      [horizontalPosition]: prev[horizontalPosition] + 1,\r\n      [verticalPosition]: prev[verticalPosition] + 1\r\n    }));\r\n    \r\n    // Determine if direction has changed\r\n    const direction = { horizontal: horizontalPosition, vertical: verticalPosition };\r\n    const hasChanged = \r\n      direction.horizontal !== lastDirectionRef.current.horizontal || \r\n      direction.vertical !== lastDirectionRef.current.vertical;\r\n    \r\n    // Update the last direction\r\n    lastDirectionRef.current = direction;\r\n    \r\n    // Only send direction change if it has changed and not throttled\r\n    if (hasChanged && !keyThrottleRef.current) {\r\n      keyThrottleRef.current = true;\r\n      \r\n      // Call the callback with appropriate key\r\n      let key = null;\r\n      if (direction.horizontal === 'left') key = 'l';\r\n      else if (direction.horizontal === 'right') key = 'r';\r\n      else if (direction.vertical === 'up') key = 'u';\r\n      else if (direction.vertical === 'down') key = 'd';\r\n      \r\n      if (key && key !== lastKeyPressRef.current) {\r\n        lastKeyPressRef.current = key;\r\n        if (onFaceDirectionChange) {\r\n          onFaceDirectionChange(key, direction);\r\n        }\r\n      }\r\n      \r\n      // Reset throttle after delay\r\n      setTimeout(() => {\r\n        keyThrottleRef.current = false;\r\n      }, 300); // 300ms throttle to prevent too many rapid direction changes\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`face-camera-control ${!enabled ? 'disabled' : ''}`} style={{ position: 'relative', width: showDebug ? inputResolution.width : '100px', height: showDebug ? inputResolution.height : '100px' }}>\r\n      {!loaded && enabled && <div className=\"loading\">Loading face detection...</div>}\r\n      \r\n      <Webcam\r\n        ref={webcamRef}\r\n        width={inputResolution.width}\r\n        height={inputResolution.height}\r\n        style={{ \r\n          visibility: showDebug ? 'hidden' : 'visible', \r\n          position: showDebug ? 'absolute' : 'relative',\r\n          borderRadius: '50%',\r\n          objectFit: 'cover',\r\n          width: showDebug ? '100%' : '100px',\r\n          height: showDebug ? '100%' : '100px'\r\n        }}\r\n        videoConstraints={videoConstraints}\r\n        onLoadedData={handleVideoLoad}\r\n      />\r\n      \r\n      <canvas\r\n        ref={canvasRef}\r\n        width={inputResolution.width}\r\n        height={inputResolution.height}\r\n        style={{ \r\n          display: showDebug ? 'block' : 'none',\r\n          position: 'absolute', \r\n          top: 0,\r\n          left: 0,\r\n          border: '1px solid black' \r\n        }}\r\n      />\r\n      \r\n      {showDebug && directionData && (\r\n        <div className=\"data-display\" style={{ position: 'absolute', bottom: '-180px', left: 0, background: 'rgba(255,255,255,0.8)', padding: '5px' }}>\r\n          <h3>Face Direction:</h3>\r\n          <pre>{JSON.stringify({\r\n            direction: lastDirectionRef.current,\r\n            yaw: Math.round(directionData.yaw),\r\n            turn: Math.round(directionData.turn)\r\n          }, null, 2)}</pre>\r\n          <div style={{ marginTop: '10px', fontSize: '12px' }}>\r\n            <p>Direction counts:</p>\r\n            <pre>{JSON.stringify(directionCounts, null, 2)}</pre>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FaceCameraControl; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}