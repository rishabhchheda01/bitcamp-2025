{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDirectionComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 640,\n  height: 480\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\n\n// Add some CSS for animations\nconst FaceDirectionStyle = `\n  @keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.1); }\n    100% { transform: scale(1); }\n  }\n  \n  @keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n  }\n  \n  .direction-indicator {\n    animation: fadeIn 0.3s ease-in-out;\n  }\n  \n  .direction-arrow {\n    animation: pulse 1.5s infinite ease-in-out;\n  }\n`;\nfunction FaceDirectionComponent() {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [faceData, setFaceData] = useState({\n    position: {\n      x: 0,\n      y: 0\n    },\n    direction: {\n      yaw: 0,\n      turn: 0\n    },\n    raw: {\n      keypoints: []\n    }\n  });\n  const [isDetecting, setIsDetecting] = useState(false);\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: false,\n        showTagNumbers: false,\n        showDirection: false\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n    };\n  }, []);\n\n  // Handle video load\n  const handleVideoLoad = async videoNode => {\n    const video = videoNode.target;\n    if (video.readyState !== 4) return;\n    if (loaded) return;\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(webcamRef.current.video, canvasRef.current, data => {\n        // Update face data when detection occurs\n        if (data && data.keypoints && data.keypoints[1]) {\n          setIsDetecting(true);\n          setFaceData({\n            position: {\n              x: Math.round(data.keypoints[1].x),\n              y: Math.round(data.keypoints[1].y)\n            },\n            direction: {\n              yaw: Math.round(data.yaw || 0),\n              turn: Math.round(data.turn || 0)\n            },\n            raw: {\n              keypoints: data.keypoints,\n              zDistance: data.zDistance,\n              xDistance: data.xDistance\n            }\n          });\n        } else {\n          setIsDetecting(false);\n        }\n      });\n      setLoaded(true);\n    }\n  };\n\n  // Function to determine face direction text - updated to match detector logic\n  const getDirectionText = () => {\n    const {\n      yaw,\n      turn\n    } = faceData.direction;\n    const screenCenter = {\n      x: inputResolution.width / 2,\n      y: inputResolution.height / 2\n    };\n\n    // Horizontal direction now correctly based on yaw angle\n    // In MediaPipe's coordinate system, a negative yaw means turning right\n    // and a positive yaw means turning left\n    let horizontalDirection = '';\n    if (yaw > 20) {\n      horizontalDirection = 'Left';\n    } else if (yaw < 0) {\n      horizontalDirection = 'Right';\n    }\n\n    // Vertical direction based on turn angle\n    // In MediaPipe's nose-based measurements, a smaller turn angle\n    // generally means looking up, while a larger angle means looking down\n    let verticalDirection = '';\n    if (turn < 20) {\n      verticalDirection = 'Up';\n    } else if (turn > 40) {\n      verticalDirection = 'Down';\n    }\n\n    // Additional position-based detection\n    // Compare nose position to center of screen\n    const noseTip = faceData.raw.keypoints && faceData.raw.keypoints[1] ? faceData.raw.keypoints[1] : faceData.position;\n\n    // If no direction was detected via angles, try position-based detection\n    if (!horizontalDirection) {\n      const horizontalOffset = noseTip.x - screenCenter.x;\n      if (Math.abs(horizontalOffset) > 50) {\n        // threshold to avoid minor movements\n        horizontalDirection = horizontalOffset > 0 ? 'Right' : 'Left';\n      }\n    }\n    if (!verticalDirection) {\n      const verticalOffset = noseTip.y - screenCenter.y;\n      if (Math.abs(verticalOffset) > 50) {\n        // threshold to avoid minor movements\n        verticalDirection = verticalOffset > 0 ? 'Down' : 'Up';\n      }\n    }\n\n    // Combine directions or return \"Center\" if no significant direction\n    if (horizontalDirection && verticalDirection) {\n      return `${verticalDirection} ${horizontalDirection}`;\n    } else if (horizontalDirection) {\n      return horizontalDirection;\n    } else if (verticalDirection) {\n      return verticalDirection;\n    } else {\n      return \"Center\";\n    }\n  };\n\n  // Function to get arrow indicator - updated to match the direction text\n  const getDirectionArrow = () => {\n    const {\n      yaw,\n      turn\n    } = faceData.direction;\n    const screenCenter = {\n      x: inputResolution.width / 2,\n      y: inputResolution.height / 2\n    };\n    const noseTip = faceData.raw.keypoints && faceData.raw.keypoints[1] ? faceData.raw.keypoints[1] : faceData.position;\n    const isLookingLeft = yaw > 20 || noseTip.x - screenCenter.x < -50;\n    const isLookingRight = yaw < 0 || noseTip.x - screenCenter.x > 50;\n    const isLookingUp = turn < 20 || noseTip.y - screenCenter.y < -50;\n    const isLookingDown = turn > 40 || noseTip.y - screenCenter.y > 50;\n\n    // Up\n    if (isLookingUp && !isLookingLeft && !isLookingRight) {\n      return \"↑\";\n    }\n    // Down\n    else if (isLookingDown && !isLookingLeft && !isLookingRight) {\n      return \"↓\";\n    }\n    // Left\n    else if (isLookingLeft && !isLookingUp && !isLookingDown) {\n      return \"←\";\n    }\n    // Right\n    else if (isLookingRight && !isLookingUp && !isLookingDown) {\n      return \"→\";\n    }\n    // Up-Left\n    else if (isLookingUp && isLookingLeft) {\n      return \"↖\";\n    }\n    // Up-Right\n    else if (isLookingUp && isLookingRight) {\n      return \"↗\";\n    }\n    // Down-Left\n    else if (isLookingDown && isLookingLeft) {\n      return \"↙\";\n    }\n    // Down-Right\n    else if (isLookingDown && isLookingRight) {\n      return \"↘\";\n    }\n    // Center\n    else {\n      return \"•\";\n    }\n  };\n\n  // Render face icon with appropriate rotation\n  const renderFaceIcon = () => {\n    const {\n      yaw,\n      turn\n    } = faceData.direction;\n\n    // Calculate a basic rotation based on yaw and turn\n    // Flip the sign for yaw to match visual expectations\n    const rotateY = Math.min(Math.max(-yaw * 1.5, -30), 30);\n    // For turn, we need to adjust the scale because the values differ\n    const rotateX = Math.min(Math.max((turn - 30) * 1.5, -30), 30);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        width: \"30px\",\n        height: \"30px\",\n        borderRadius: \"50%\",\n        backgroundColor: \"rgba(0, 242, 254, 0.2)\",\n        border: \"2px solid rgba(0, 242, 254, 0.5)\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        transform: `perspective(100px) rotateY(${rotateY}deg) rotateX(${rotateX}deg)`,\n        transition: \"transform 0.3s ease\",\n        position: \"relative\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: \"flex\",\n          gap: \"6px\",\n          position: \"absolute\",\n          top: \"8px\"\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            width: \"4px\",\n            height: \"4px\",\n            borderRadius: \"50%\",\n            backgroundColor: \"#00f2fe\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 262,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            width: \"4px\",\n            height: \"4px\",\n            borderRadius: \"50%\",\n            backgroundColor: \"#00f2fe\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 268,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 256,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          width: \"8px\",\n          height: \"3px\",\n          borderRadius: \"2px\",\n          backgroundColor: \"#00f2fe\",\n          position: \"absolute\",\n          bottom: \"8px\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 276,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 240,\n      columnNumber: 7\n    }, this);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"style\", {\n      children: FaceDirectionStyle\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 291,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        visibility: \"hidden\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        width: inputResolution.width,\n        height: inputResolution.height,\n        videoConstraints: videoConstraints,\n        onLoadedData: handleVideoLoad\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        width: inputResolution.width,\n        height: inputResolution.height\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 7\n    }, this), isDetecting && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"direction-indicator\",\n      style: {\n        position: \"fixed\",\n        bottom: \"20px\",\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n        color: \"#00f2fe\",\n        padding: \"8px 16px\",\n        borderRadius: \"8px\",\n        fontFamily: \"monospace\",\n        fontSize: \"14px\",\n        zIndex: 1000,\n        display: \"flex\",\n        gap: \"16px\",\n        alignItems: \"center\",\n        boxShadow: \"0 0 10px rgba(0, 242, 254, 0.3)\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Position: x=\", faceData.position.x, \", y=\", faceData.position.y]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 329,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Direction: yaw=\", faceData.direction.yaw, \"\\xB0, turn=\", faceData.direction.turn, \"\\xB0\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 332,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          backgroundColor: \"rgba(0, 242, 254, 0.2)\",\n          padding: \"4px 12px\",\n          borderRadius: \"6px\",\n          fontWeight: \"bold\",\n          fontSize: \"16px\",\n          display: \"flex\",\n          alignItems: \"center\",\n          gap: \"12px\"\n        },\n        children: [renderFaceIcon(), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"direction-arrow\",\n          style: {\n            fontSize: \"24px\"\n          },\n          children: getDirectionArrow()\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: getDirectionText()\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 347,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 335,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 312,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 289,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceDirectionComponent, \"6BwWDK3ikRXjmrbNfF8AlvEbju4=\");\n_c = FaceDirectionComponent;\nexport default FaceDirectionComponent;\nvar _c;\n$RefreshReg$(_c, \"FaceDirectionComponent\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","FaceDirectionStyle","FaceDirectionComponent","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","faceData","setFaceData","position","x","y","direction","yaw","turn","raw","keypoints","isDetecting","setIsDetecting","initializeDetector","options","showMesh","showTagNumbers","showDirection","faceDetector","stop","handleVideoLoad","videoNode","video","target","readyState","current","start","data","Math","round","zDistance","xDistance","getDirectionText","screenCenter","horizontalDirection","verticalDirection","noseTip","horizontalOffset","abs","verticalOffset","getDirectionArrow","isLookingLeft","isLookingRight","isLookingUp","isLookingDown","renderFaceIcon","rotateY","min","max","rotateX","style","borderRadius","backgroundColor","border","display","alignItems","justifyContent","transform","transition","children","gap","top","fileName","_jsxFileName","lineNumber","columnNumber","bottom","visibility","ref","onLoadedData","className","left","color","padding","fontFamily","fontSize","zIndex","boxShadow","fontWeight","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDirectionComponent.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\n\nconst inputResolution = {\n  width: 640,\n  height: 480,\n};\n\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\",\n};\n\n// Add some CSS for animations\nconst FaceDirectionStyle = `\n  @keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.1); }\n    100% { transform: scale(1); }\n  }\n  \n  @keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n  }\n  \n  .direction-indicator {\n    animation: fadeIn 0.3s ease-in-out;\n  }\n  \n  .direction-arrow {\n    animation: pulse 1.5s infinite ease-in-out;\n  }\n`;\n\nfunction FaceDirectionComponent() {\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [faceData, setFaceData] = useState({\n    position: { x: 0, y: 0 },\n    direction: { yaw: 0, turn: 0 },\n    raw: { keypoints: [] }\n  });\n  const [isDetecting, setIsDetecting] = useState(false);\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: false,\n        showTagNumbers: false,\n        showDirection: false\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n    };\n  }, []);\n\n  // Handle video load\n  const handleVideoLoad = async (videoNode) => {\n    const video = videoNode.target;\n    if (video.readyState !== 4) return;\n    if (loaded) return;\n\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(\n        webcamRef.current.video, \n        canvasRef.current, \n        (data) => {\n          // Update face data when detection occurs\n          if (data && data.keypoints && data.keypoints[1]) {\n            setIsDetecting(true);\n            setFaceData({\n              position: {\n                x: Math.round(data.keypoints[1].x),\n                y: Math.round(data.keypoints[1].y)\n              },\n              direction: {\n                yaw: Math.round(data.yaw || 0),\n                turn: Math.round(data.turn || 0)\n              },\n              raw: {\n                keypoints: data.keypoints,\n                zDistance: data.zDistance,\n                xDistance: data.xDistance\n              }\n            });\n          } else {\n            setIsDetecting(false);\n          }\n        }\n      );\n      setLoaded(true);\n    }\n  };\n\n  // Function to determine face direction text - updated to match detector logic\n  const getDirectionText = () => {\n    const { yaw, turn } = faceData.direction;\n    const screenCenter = {\n      x: inputResolution.width / 2,\n      y: inputResolution.height / 2\n    };\n    \n    // Horizontal direction now correctly based on yaw angle\n    // In MediaPipe's coordinate system, a negative yaw means turning right\n    // and a positive yaw means turning left\n    let horizontalDirection = '';\n    if (yaw > 20) {\n      horizontalDirection = 'Left';\n    } else if (yaw < 0) {\n      horizontalDirection = 'Right';\n    }\n    \n    // Vertical direction based on turn angle\n    // In MediaPipe's nose-based measurements, a smaller turn angle\n    // generally means looking up, while a larger angle means looking down\n    let verticalDirection = '';\n    if (turn < 20) {\n      verticalDirection = 'Up';\n    } else if (turn > 40) {\n      verticalDirection = 'Down';\n    }\n    \n    // Additional position-based detection\n    // Compare nose position to center of screen\n    const noseTip = faceData.raw.keypoints && faceData.raw.keypoints[1] \n      ? faceData.raw.keypoints[1] \n      : faceData.position;\n    \n    // If no direction was detected via angles, try position-based detection\n    if (!horizontalDirection) {\n      const horizontalOffset = noseTip.x - screenCenter.x;\n      if (Math.abs(horizontalOffset) > 50) { // threshold to avoid minor movements\n        horizontalDirection = horizontalOffset > 0 ? 'Right' : 'Left';\n      }\n    }\n    \n    if (!verticalDirection) {\n      const verticalOffset = noseTip.y - screenCenter.y;\n      if (Math.abs(verticalOffset) > 50) { // threshold to avoid minor movements\n        verticalDirection = verticalOffset > 0 ? 'Down' : 'Up';\n      }\n    }\n    \n    // Combine directions or return \"Center\" if no significant direction\n    if (horizontalDirection && verticalDirection) {\n      return `${verticalDirection} ${horizontalDirection}`;\n    } else if (horizontalDirection) {\n      return horizontalDirection;\n    } else if (verticalDirection) {\n      return verticalDirection;\n    } else {\n      return \"Center\";\n    }\n  };\n\n  // Function to get arrow indicator - updated to match the direction text\n  const getDirectionArrow = () => {\n    const { yaw, turn } = faceData.direction;\n    const screenCenter = {\n      x: inputResolution.width / 2,\n      y: inputResolution.height / 2\n    };\n    \n    const noseTip = faceData.raw.keypoints && faceData.raw.keypoints[1] \n      ? faceData.raw.keypoints[1] \n      : faceData.position;\n    \n    const isLookingLeft = yaw > 20 || (noseTip.x - screenCenter.x < -50);\n    const isLookingRight = yaw < 0 || (noseTip.x - screenCenter.x > 50);\n    const isLookingUp = turn < 20 || (noseTip.y - screenCenter.y < -50);\n    const isLookingDown = turn > 40 || (noseTip.y - screenCenter.y > 50);\n    \n    // Up\n    if (isLookingUp && !isLookingLeft && !isLookingRight) {\n      return \"↑\";\n    }\n    // Down\n    else if (isLookingDown && !isLookingLeft && !isLookingRight) {\n      return \"↓\";\n    }\n    // Left\n    else if (isLookingLeft && !isLookingUp && !isLookingDown) {\n      return \"←\";\n    }\n    // Right\n    else if (isLookingRight && !isLookingUp && !isLookingDown) {\n      return \"→\";\n    }\n    // Up-Left\n    else if (isLookingUp && isLookingLeft) {\n      return \"↖\";\n    }\n    // Up-Right\n    else if (isLookingUp && isLookingRight) {\n      return \"↗\";\n    }\n    // Down-Left\n    else if (isLookingDown && isLookingLeft) {\n      return \"↙\";\n    }\n    // Down-Right\n    else if (isLookingDown && isLookingRight) {\n      return \"↘\";\n    }\n    // Center\n    else {\n      return \"•\";\n    }\n  };\n\n  // Render face icon with appropriate rotation\n  const renderFaceIcon = () => {\n    const { yaw, turn } = faceData.direction;\n    \n    // Calculate a basic rotation based on yaw and turn\n    // Flip the sign for yaw to match visual expectations\n    const rotateY = Math.min(Math.max(-yaw * 1.5, -30), 30);\n    // For turn, we need to adjust the scale because the values differ\n    const rotateX = Math.min(Math.max((turn - 30) * 1.5, -30), 30);\n    \n    return (\n      <div\n        style={{\n          width: \"30px\",\n          height: \"30px\",\n          borderRadius: \"50%\",\n          backgroundColor: \"rgba(0, 242, 254, 0.2)\",\n          border: \"2px solid rgba(0, 242, 254, 0.5)\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          transform: `perspective(100px) rotateY(${rotateY}deg) rotateX(${rotateX}deg)`,\n          transition: \"transform 0.3s ease\",\n          position: \"relative\",\n        }}\n      >\n        {/* Eyes */}\n        <div style={{\n          display: \"flex\",\n          gap: \"6px\",\n          position: \"absolute\",\n          top: \"8px\"\n        }}>\n          <div style={{\n            width: \"4px\",\n            height: \"4px\",\n            borderRadius: \"50%\",\n            backgroundColor: \"#00f2fe\"\n          }}></div>\n          <div style={{\n            width: \"4px\",\n            height: \"4px\",\n            borderRadius: \"50%\",\n            backgroundColor: \"#00f2fe\"\n          }}></div>\n        </div>\n        {/* Mouth */}\n        <div style={{\n          width: \"8px\",\n          height: \"3px\",\n          borderRadius: \"2px\",\n          backgroundColor: \"#00f2fe\",\n          position: \"absolute\",\n          bottom: \"8px\"\n        }}></div>\n      </div>\n    );\n  };\n\n  return (\n    <div>\n      {/* Add the styles */}\n      <style>{FaceDirectionStyle}</style>\n      \n      {/* Hidden webcam and canvas for detection */}\n      <div style={{ position: \"absolute\", visibility: \"hidden\" }}>\n        <Webcam\n          ref={webcamRef}\n          width={inputResolution.width}\n          height={inputResolution.height}\n          videoConstraints={videoConstraints}\n          onLoadedData={handleVideoLoad}\n        />\n        \n        <canvas\n          ref={canvasRef}\n          width={inputResolution.width}\n          height={inputResolution.height}\n        />\n      </div>\n\n      {/* Display face data with direction text, arrow and face icon */}\n      {isDetecting && (\n        <div className=\"direction-indicator\" style={{ \n          position: \"fixed\", \n          bottom: \"20px\",\n          left: \"50%\",\n          transform: \"translateX(-50%)\",\n          backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n          color: \"#00f2fe\",\n          padding: \"8px 16px\",\n          borderRadius: \"8px\",\n          fontFamily: \"monospace\",\n          fontSize: \"14px\",\n          zIndex: 1000,\n          display: \"flex\",\n          gap: \"16px\",\n          alignItems: \"center\",\n          boxShadow: \"0 0 10px rgba(0, 242, 254, 0.3)\"\n        }}>\n          <div>\n            Position: x={faceData.position.x}, y={faceData.position.y}\n          </div>\n          <div>\n            Direction: yaw={faceData.direction.yaw}°, turn={faceData.direction.turn}°\n          </div>\n          <div style={{ \n            backgroundColor: \"rgba(0, 242, 254, 0.2)\",\n            padding: \"4px 12px\",\n            borderRadius: \"6px\",\n            fontWeight: \"bold\",\n            fontSize: \"16px\",\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: \"12px\"\n          }}>\n            {renderFaceIcon()}\n            <span className=\"direction-arrow\" style={{ fontSize: \"24px\" }}>{getDirectionArrow()}</span>\n            <span>{getDirectionText()}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default FaceDirectionComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}