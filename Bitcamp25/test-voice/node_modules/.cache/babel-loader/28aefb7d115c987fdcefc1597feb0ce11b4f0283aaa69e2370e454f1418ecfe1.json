{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { RetellWebClient } from \"retell-client-js-sdk\";\nimport SplineLoader from './SplineLoader';\nimport SplineViewer from './SplineViewer';\nimport './index.css';\nimport SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';\nimport agentIcon from './assets/agent-icon.svg';\nimport userIcon from './assets/user-icon.svg';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  // Add a ref to maintain the Spline instance\n  const splineInstanceRef = useRef(null);\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [retellWebClient, setRetellWebClient] = useState(null);\n  const [eventStatus, setEventStatus] = useState({\n    callStarted: false,\n    callEnded: false,\n    agentStartTalking: false,\n    agentStopTalking: false,\n    error: null,\n    transcript: ''\n  });\n  const [micPermission, setMicPermission] = useState(null);\n  const [accessToken, setAccessToken] = useState('');\n  const [isGeneratingToken, setIsGeneratingToken] = useState(false);\n  const [callInfo, setCallInfo] = useState(null);\n  const [loadingComplete, setLoadingComplete] = useState(false);\n  const [showUI, setShowUI] = useState(true);\n  // Add state to control the mounting/unmounting of Spline\n  const [splineInitialized, setSplineInitialized] = useState(false);\n  // Add refs for animation control\n  const animationTimerRef = useRef(null);\n  const lastKeyPressRef = useRef(null);\n  // Track if key is being pressed\n  const keyPressedRef = useRef({});\n  // State for graph visualization\n  const [showGraphs, setShowGraphs] = useState(false);\n  const [graphType, setGraphType] = useState('bar'); // 'bar', 'line', 'pie', 'scatter'\n  const graphTimerRef = useRef(null);\n  const [messages, setMessages] = useState([]);\n  const [isAgentSpeaking, setIsAgentSpeaking] = useState(false);\n  const [transcript, setTranscript] = useState('');\n  const graphKeywords = ['graph', 'chart', 'stats', 'data', 'visualization', 'metrics', 'numbers'];\n  const graphIntervalRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const {\n    transcript: currentTranscript,\n    listening,\n    resetTranscript,\n    browserSupportsSpeechRecognition\n  } = useSpeechRecognition();\n\n  // Key press duration in milliseconds (0.5 seconds)\n  const KEY_PRESS_DURATION = 500;\n\n  // Agent ID for Retell\n  const AGENT_ID = \"agent_90c352c3f8973e7127b472335e\";\n\n  // Server endpoint for token generation\n  const TOKEN_SERVER_URL = \"http://127.0.0.1:5000/api/generate-token\";\n\n  // Function to check if the transcript contains data visualization keywords\n  const checkForGraphKeywords = transcript => {\n    if (!transcript) return false;\n    const lowerText = transcript.toLowerCase();\n    return lowerText.includes('chart') || lowerText.includes('graph') || lowerText.includes('stats') || lowerText.includes('statistics') || lowerText.includes('visualization') || lowerText.includes('plot') || lowerText.includes('diagram');\n  };\n\n  // Function to handle graph visualization\n  const handleGraphVisualization = transcript => {\n    const shouldShowGraphs = checkForGraphKeywords(transcript);\n    if (shouldShowGraphs && !showGraphs) {\n      // Show graphs when keywords are detected\n      setShowGraphs(true);\n\n      // Randomly select a graph type to display\n      const graphTypes = ['bar', 'line', 'pie', 'scatter'];\n      const randomType = graphTypes[Math.floor(Math.random() * graphTypes.length)];\n      setGraphType(randomType);\n\n      // Cycle through graph types while keywords are present\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n      }\n      graphTimerRef.current = setInterval(() => {\n        setGraphType(prevType => {\n          const nextIndex = (graphTypes.indexOf(prevType) + 1) % graphTypes.length;\n          return graphTypes[nextIndex];\n        });\n      }, 3000); // Change graph type every 3 seconds\n    } else if (!shouldShowGraphs && showGraphs && !eventStatus.agentStartTalking) {\n      // Hide graphs when keywords are no longer detected and agent stops talking\n      setShowGraphs(false);\n\n      // Clean up the timer\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n        graphTimerRef.current = null;\n      }\n    }\n  };\n\n  // Enhanced function to simulate a keyboard press with multiple methods\n  const simulateKeyPress = key => {\n    // Prevent rapid repeated presses\n    if (keyPressedRef.current[key]) return;\n    keyPressedRef.current[key] = true;\n\n    // Method 1: Use our custom SplineViewer reference method if available\n    if (splineInstanceRef.current) {\n      try {\n        // Send keydown event\n        splineInstanceRef.current.sendKeyDown(key);\n        console.log(`Sent keydown to Spline via ref: ${key}`);\n\n        // Schedule keyup after KEY_PRESS_DURATION\n        setTimeout(() => {\n          splineInstanceRef.current.sendKeyUp(key);\n          console.log(`Sent keyup to Spline via ref: ${key}`);\n        }, KEY_PRESS_DURATION);\n      } catch (e) {\n        console.error(\"Error using splineInstanceRef sendKey:\", e);\n      }\n    }\n\n    // Method 2: Try to dispatch to active element (sometimes this works better)\n    try {\n      if (document.activeElement) {\n        const event = new KeyboardEvent('keydown', {\n          key: key,\n          code: `Key${key.toUpperCase()}`,\n          keyCode: key.charCodeAt(0),\n          which: key.charCodeAt(0),\n          bubbles: true,\n          cancelable: true,\n          composed: true\n        });\n        document.activeElement.dispatchEvent(event);\n\n        // Schedule keyup after KEY_PRESS_DURATION\n        setTimeout(() => {\n          const upEvent = new KeyboardEvent('keyup', {\n            key: key,\n            code: `Key${key.toUpperCase()}`,\n            keyCode: key.charCodeAt(0),\n            which: key.charCodeAt(0),\n            bubbles: true,\n            cancelable: true,\n            composed: true\n          });\n          document.activeElement.dispatchEvent(upEvent);\n        }, KEY_PRESS_DURATION);\n      }\n    } catch (e) {\n      console.error(\"Error dispatching to active element:\", e);\n    }\n\n    // Method 3: Manually activate the test buttons through DOM\n    try {\n      // Create a mouse click event on the corresponding test button\n      const buttonSelector = key === 'u' ? '.test-btn:nth-child(1)' : key === 'd' ? '.test-btn:nth-child(2)' : key === 'l' ? '.test-btn:nth-child(3)' : '.test-btn:nth-child(4)';\n      const button = document.querySelector(buttonSelector);\n      if (button) {\n        // Add active state with CSS\n        button.classList.add('active-test-btn');\n\n        // Remove active state after KEY_PRESS_DURATION\n        setTimeout(() => {\n          button.classList.remove('active-test-btn');\n        }, KEY_PRESS_DURATION);\n      }\n    } catch (e) {\n      console.error(\"Error activating test button:\", e);\n    }\n\n    // Method 4: Try to locate and interact directly with the Spline iframe\n    try {\n      const splineContainer = document.querySelector('.spline-container');\n      if (splineContainer) {\n        const iframe = splineContainer.querySelector('iframe');\n        if (iframe) {\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n\n          // Try to find body or canvas element\n          const target = iframeDoc.querySelector('canvas') || iframeDoc.body || iframeDoc;\n          if (target) {\n            const event = new KeyboardEvent('keydown', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              which: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            target.dispatchEvent(event);\n\n            // Schedule keyup after KEY_PRESS_DURATION\n            setTimeout(() => {\n              const upEvent = new KeyboardEvent('keyup', {\n                key: key,\n                code: `Key${key.toUpperCase()}`,\n                keyCode: key.charCodeAt(0),\n                which: key.charCodeAt(0),\n                bubbles: true,\n                cancelable: true\n              });\n              target.dispatchEvent(upEvent);\n            }, KEY_PRESS_DURATION);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(\"Error dispatching directly to iframe content:\", e);\n    }\n\n    // Store the last key press\n    lastKeyPressRef.current = key;\n\n    // Reset pressed state after KEY_PRESS_DURATION plus a small buffer\n    setTimeout(() => {\n      keyPressedRef.current[key] = false;\n    }, KEY_PRESS_DURATION + 100);\n  };\n\n  // Function to handle actual keyboard events (for testing purposes)\n  const handleKeyDown = e => {\n    // We'll only log and process the keys we're interested in\n    if (['u', 'd', 'l', 'r'].includes(e.key)) {\n      console.log(`Actual key press: ${e.key}`);\n\n      // We should also manually trigger the same spline animation for consistent behavior\n      if (!keyPressedRef.current[e.key]) {\n        testAnimation(e.key);\n      }\n    }\n  };\n\n  // Add a hook to listen for real keyboard events for debugging\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n\n  // Function to start animation based on talking state\n  const startTalkingAnimation = () => {\n    // Clear any existing animation timer\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n    }\n\n    // Reset the last key press to force starting with up movement\n    lastKeyPressRef.current = null;\n\n    // Start with an initial up key press to ensure we begin with up/down\n    simulateKeyPress('u');\n\n    // Track the previous negation state\n    let wasNegation = false;\n\n    // Set up a new animation timer to simulate key presses while talking\n    // Use a longer interval to account for the longer key press duration\n    animationTimerRef.current = setInterval(() => {\n      // Check if the transcript contains negation words\n      const hasNegation = eventStatus.transcript && (eventStatus.transcript.toLowerCase().includes('no') || eventStatus.transcript.toLowerCase().includes('not') || eventStatus.transcript.toLowerCase().includes(\"don't\") || eventStatus.transcript.toLowerCase().includes(\"doesn't\"));\n\n      // If negation state changed from true to false, reset the animation pattern\n      if (wasNegation && !hasNegation) {\n        console.log(\"Negation ended, resetting to up/down movement\");\n        lastKeyPressRef.current = null;\n        simulateKeyPress('u');\n      }\n\n      // Update the previous negation state\n      wasNegation = hasNegation;\n\n      // If there's negation, use left-right movements\n      if (hasNegation) {\n        // Alternate between left and right\n        if (lastKeyPressRef.current === 'l') {\n          simulateKeyPress('r');\n        } else {\n          simulateKeyPress('l');\n        }\n      } else {\n        // Otherwise use up-down movements\n        if (lastKeyPressRef.current === 'u') {\n          simulateKeyPress('d');\n        } else {\n          simulateKeyPress('u');\n        }\n      }\n    }, KEY_PRESS_DURATION + 200); // Animation interval is longer to account for key press duration\n  };\n\n  // Function to stop animation\n  const stopTalkingAnimation = () => {\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n      animationTimerRef.current = null;\n    }\n\n    // If the agent stops talking, schedule hiding the graphs after a short delay\n    if (showGraphs) {\n      setTimeout(() => {\n        setShowGraphs(false);\n\n        // Clean up the graph timer\n        if (graphTimerRef.current) {\n          clearInterval(graphTimerRef.current);\n          graphTimerRef.current = null;\n        }\n      }, 2000);\n    }\n  };\n\n  // Function to manually trigger animation for testing \n  const testAnimation = direction => {\n    simulateKeyPress(direction);\n  };\n\n  // Effect to update graph visualization when transcript changes\n  useEffect(() => {\n    if (eventStatus.transcript) {\n      handleGraphVisualization(eventStatus.transcript);\n    }\n  }, [eventStatus.transcript, eventStatus.agentStartTalking]);\n\n  // Clean up graph timer on component unmount\n  useEffect(() => {\n    return () => {\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n        graphTimerRef.current = null;\n      }\n    };\n  }, []);\n  useEffect(() => {\n    // Initialize the RetellWebClient\n    const client = new RetellWebClient();\n    setRetellWebClient(client);\n\n    // Check for microphone permissions\n    checkMicrophonePermission();\n\n    // Set up event listeners\n    client.on(\"call_started\", () => {\n      console.log(\"call started\");\n      setEventStatus(prev => ({\n        ...prev,\n        callStarted: true,\n        callEnded: false\n      }));\n    });\n    client.on(\"call_ended\", () => {\n      console.log(\"call ended\");\n      setIsCallActive(false);\n      setEventStatus(prev => ({\n        ...prev,\n        callEnded: true\n      }));\n      stopTalkingAnimation();\n    });\n    client.on(\"agent_start_talking\", () => {\n      console.log(\"agent_start_talking\");\n      setEventStatus(prev => ({\n        ...prev,\n        agentStartTalking: true,\n        agentStopTalking: false\n      }));\n      startTalkingAnimation();\n    });\n    client.on(\"agent_stop_talking\", () => {\n      console.log(\"agent_stop_talking\");\n      setEventStatus(prev => ({\n        ...prev,\n        agentStopTalking: true,\n        agentStartTalking: false\n      }));\n      stopTalkingAnimation();\n    });\n    client.on(\"update\", update => {\n      console.log(\"Update received:\", update);\n      if (update.transcript) {\n        // Check if transcript is an object with role and content properties\n        if (typeof update.transcript === 'object' && update.transcript.role && update.transcript.content) {\n          // Extract the content text\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: update.transcript.content\n          }));\n        }\n        // Check if transcript is an array of message objects\n        else if (Array.isArray(update.transcript)) {\n          // Map through messages and format them\n          const formattedTranscript = update.transcript.map(msg => {\n            if (typeof msg === 'object' && msg.role && msg.content) {\n              return `${msg.role}: ${msg.content}`;\n            }\n            return String(msg); // Convert to string if it's some other type\n          }).join('\\n');\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: formattedTranscript\n          }));\n        }\n        // If it's a string or can be converted to string\n        else {\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: String(update.transcript)\n          }));\n        }\n      }\n    });\n    client.on(\"metadata\", metadata => {\n      console.log(\"Metadata received:\", metadata);\n    });\n    client.on(\"error\", error => {\n      console.error(\"An error occurred:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Unknown error\"\n      }));\n      client.stopCall();\n      stopTalkingAnimation();\n    });\n\n    // Clean up event listeners and animation on component unmount\n    return () => {\n      stopTalkingAnimation();\n      if (client) {\n        client.stopCall();\n      }\n    };\n  }, []);\n\n  // Effect to handle animation when talking state changes\n  useEffect(() => {\n    if (eventStatus.agentStartTalking && !eventStatus.agentStopTalking) {\n      startTalkingAnimation();\n    } else {\n      stopTalkingAnimation();\n    }\n  }, [eventStatus.agentStartTalking, eventStatus.agentStopTalking]);\n\n  // Function to generate an access token from the server\n  const generateAccessToken = async () => {\n    try {\n      setIsGeneratingToken(true);\n      setEventStatus(prev => ({\n        ...prev,\n        error: null\n      }));\n      console.log(\"Requesting access token from server...\");\n\n      // Make the API call to our server endpoint\n      const response = await fetch(TOKEN_SERVER_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          agent_id: AGENT_ID\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `Server responded with status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.access_token) {\n        throw new Error(\"No access token received from server\");\n      }\n      console.log(\"Access token received from server:\", data.access_token);\n      setAccessToken(data.access_token);\n      setCallInfo(data); // Store the full call info for reference\n      setIsGeneratingToken(false);\n      return data.access_token;\n    } catch (error) {\n      console.error(\"Failed to generate access token:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Failed to generate access token\"\n      }));\n      setIsGeneratingToken(false);\n      return null;\n    }\n  };\n  const checkMicrophonePermission = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      setMicPermission('granted');\n      // Stop the stream tracks immediately\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      console.error('Microphone permission denied:', error);\n      setMicPermission('denied');\n    }\n  };\n  const requestMicrophonePermission = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      setMicPermission('granted');\n      return true;\n    } catch (error) {\n      console.error('Failed to get microphone permission:', error);\n      setMicPermission('denied');\n      return false;\n    }\n  };\n  const startCall = async () => {\n    if (!retellWebClient || isCallActive) return;\n\n    // First ensure we have microphone permissions\n    if (micPermission !== 'granted') {\n      const permissionGranted = await requestMicrophonePermission();\n      if (!permissionGranted) {\n        alert('Microphone permission is required to start a call');\n        return;\n      }\n    }\n    try {\n      // Reset event status\n      setEventStatus({\n        callStarted: false,\n        callEnded: false,\n        agentStartTalking: false,\n        agentStopTalking: false,\n        error: null,\n        transcript: ''\n      });\n\n      // Ensure we have a valid token\n      if (!accessToken) {\n        const token = await generateAccessToken();\n        if (!token) {\n          throw new Error(\"Failed to generate a valid access token\");\n        }\n      }\n      console.log(\"Starting call with access token...\");\n\n      // Start the call using the access token\n      await retellWebClient.startCall({\n        accessToken: accessToken,\n        sampleRate: 24000,\n        captureDeviceId: \"default\",\n        emitRawAudioSamples: false\n      });\n      setIsCallActive(true);\n    } catch (error) {\n      console.error(\"Failed to start call:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Failed to start call\"\n      }));\n    }\n  };\n  const stopCall = () => {\n    if (retellWebClient && isCallActive) {\n      retellWebClient.stopCall();\n      setIsCallActive(false);\n    }\n  };\n\n  // Function to check if token is expired (tokens are valid for 30 seconds)\n  const isTokenExpired = () => {\n    // If we don't have token info, consider it expired\n    if (!accessToken || !callInfo) return true;\n\n    // Track when we received the token in our application\n    if (!callInfo._tokenReceivedTime) {\n      // If this is the first time checking, add a timestamp of when we received it\n      callInfo._tokenReceivedTime = Date.now();\n      setCallInfo({\n        ...callInfo\n      }); // Update the state to save this timestamp\n      return false; // Token is fresh\n    }\n\n    // Calculate how long ago we received the token\n    const tokenReceivedTime = callInfo._tokenReceivedTime;\n    const currentTime = Date.now();\n    const tokenAgeInSeconds = (currentTime - tokenReceivedTime) / 1000;\n\n    // Token expires after 30 seconds, but we consider it expired at 25s\n    // to give us a buffer to generate a new one\n    return tokenAgeInSeconds > 25;\n  };\n\n  // New function to handle loading completion and initialize Spline only once\n  const handleLoadingComplete = () => {\n    setLoadingComplete(true);\n    setSplineInitialized(true);\n  };\n\n  // Render functions for different graph types\n  const renderGraph = () => {\n    switch (graphType) {\n      case 'bar':\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"neon-graph bar-graph\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bar\",\n            style: {\n              height: '60%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 609,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bar\",\n            style: {\n              height: '80%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 610,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bar\",\n            style: {\n              height: '40%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 611,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bar\",\n            style: {\n              height: '90%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 612,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"bar\",\n            style: {\n              height: '65%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 613,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 608,\n          columnNumber: 11\n        }, this);\n      case 'line':\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"neon-graph line-graph\",\n          children: /*#__PURE__*/_jsxDEV(\"svg\", {\n            viewBox: \"0 0 100 50\",\n            children: /*#__PURE__*/_jsxDEV(\"path\", {\n              d: \"M0,40 L20,30 L40,35 L60,15 L80,25 L100,10\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 620,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 619,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 618,\n          columnNumber: 11\n        }, this);\n      case 'pie':\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"neon-graph pie-graph\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"pie-slice slice1\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 627,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"pie-slice slice2\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 628,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"pie-slice slice3\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 629,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 626,\n          columnNumber: 11\n        }, this);\n      case 'scatter':\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"neon-graph scatter-graph\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '20%',\n              left: '30%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 635,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '60%',\n              left: '70%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 636,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '40%',\n              left: '50%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 637,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '70%',\n              left: '20%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 638,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '30%',\n              left: '80%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 639,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"dot\",\n            style: {\n              top: '50%',\n              left: '40%'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 640,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 634,\n          columnNumber: 11\n        }, this);\n      default:\n        return null;\n    }\n  };\n  useEffect(() => {\n    setTranscript(currentTranscript);\n  }, [currentTranscript]);\n  useEffect(() => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: 'smooth'\n    });\n  }, [messages]);\n\n  // Function to check for graph-related keywords in the transcript\n  const checkForGraphKeywordsSpeech = text => {\n    if (!text) return false;\n    const textLower = text.toLowerCase();\n    return graphKeywords.some(keyword => textLower.includes(keyword));\n  };\n\n  // Function to handle graph visualization based on keywords and agent speaking status\n  const handleGraphVisualizationSpeech = () => {\n    const hasGraphKeywords = checkForGraphKeywordsSpeech(transcript);\n    if (hasGraphKeywords && isAgentSpeaking) {\n      setShowGraphs(true);\n\n      // Start cycling through graph types if not already cycling\n      if (!graphIntervalRef.current) {\n        graphIntervalRef.current = setInterval(() => {\n          setGraphType(prevType => {\n            switch (prevType) {\n              case 'bar':\n                return 'line';\n              case 'line':\n                return 'pie';\n              case 'pie':\n                return 'scatter';\n              case 'scatter':\n                return 'bar';\n              default:\n                return 'bar';\n            }\n          });\n        }, 3000); // Change graph type every 3 seconds\n      }\n    } else if (!isAgentSpeaking && showGraphs) {\n      // Fade out graphs when agent stops speaking\n      setTimeout(() => {\n        setShowGraphs(false);\n        if (graphIntervalRef.current) {\n          clearInterval(graphIntervalRef.current);\n          graphIntervalRef.current = null;\n        }\n      }, 2000); // 2 second delay before hiding graphs\n    }\n  };\n\n  // Monitor for changes in transcript and agent speaking status\n  useEffect(() => {\n    handleGraphVisualizationSpeech();\n  }, [transcript, isAgentSpeaking]);\n\n  // Clean up interval on component unmount\n  useEffect(() => {\n    return () => {\n      if (graphIntervalRef.current) {\n        clearInterval(graphIntervalRef.current);\n      }\n    };\n  }, []);\n  const handleStartListening = () => {\n    resetTranscript();\n    SpeechRecognition.startListening({\n      continuous: true\n    });\n  };\n  const handleStopListening = () => {\n    SpeechRecognition.stopListening();\n  };\n  const toggleAgentSpeaking = () => {\n    setIsAgentSpeaking(!isAgentSpeaking);\n  };\n  const handleSendMessage = () => {\n    if (transcript.trim() === '') return;\n    const newMessage = {\n      text: transcript,\n      sender: 'user',\n      timestamp: new Date().toISOString()\n    };\n    setMessages([...messages, newMessage]);\n    resetTranscript();\n  };\n  const renderAgentResponse = () => {\n    // Simulate agent responding\n    const agentMessage = {\n      text: \"I'm processing your request. Here are some interesting statistics and data visualizations that might help you understand the trends better.\",\n      sender: 'agent',\n      timestamp: new Date().toISOString()\n    };\n    setTimeout(() => {\n      setMessages([...messages, agentMessage]);\n      setIsAgentSpeaking(true);\n\n      // Simulate agent finishing speaking after 5 seconds\n      setTimeout(() => {\n        setIsAgentSpeaking(false);\n      }, 5000);\n    }, 1000);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: !loadingComplete ? /*#__PURE__*/_jsxDEV(SplineLoader, {\n      onLoadingComplete: handleLoadingComplete\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 758,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"spline-container\",\n        children: [splineInitialized && /*#__PURE__*/_jsxDEV(SplineViewer, {\n          ref: splineInstanceRef,\n          url: \"https://prod.spline.design/MLpQD4kA7Miyykt9/scene.splinecode\",\n          options: {\n            hint: true,\n            'loading-anim-type': 'spinner-small-dark'\n          },\n          persistOnUpdate: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 765,\n          columnNumber: 15\n        }, this), showGraphs && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `graph-overlay ${showGraphs ? 'visible' : ''}`,\n          children: renderGraph()\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 778,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 762,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `sidebar ${showUI ? 'open' : 'closed'} ${showGraphs ? 'fade-out' : ''}`,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"toggle-ui\",\n          onClick: () => setShowUI(!showUI),\n          children: showUI ? '×' : '≡'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 786,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"sidebar-content\",\n          children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"AI Voice\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 791,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"status-indicator\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: `status-dot ${isCallActive ? 'active' : 'inactive'}`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 794,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              children: isCallActive ? 'Connected' : 'Disconnected'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 795,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 793,\n            columnNumber: 15\n          }, this), micPermission !== 'granted' && /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: requestMicrophonePermission,\n            className: \"btn-secondary btn-small\",\n            children: \"Enable Mic\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 799,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"control-buttons\",\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: !accessToken || isTokenExpired() ? generateAccessToken : startCall,\n              disabled: isCallActive || isGeneratingToken,\n              className: \"btn-primary\",\n              children: !accessToken || isTokenExpired() ? \"Connect\" : isGeneratingToken ? \"...\" : \"Start\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 808,\n              columnNumber: 17\n            }, this), isCallActive && /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: stopCall,\n              className: \"btn-danger\",\n              children: \"End\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 821,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 807,\n            columnNumber: 15\n          }, this), eventStatus.error && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"error-badge\",\n            children: [\"Error: \", eventStatus.error]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 831,\n            columnNumber: 17\n          }, this), isCallActive && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `talking-indicator ${showGraphs ? 'fade-out' : ''}`,\n            children: eventStatus.agentStartTalking && !eventStatus.agentStopTalking ? /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"wave-animation\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 841,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 842,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 843,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 844,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 840,\n              columnNumber: 21\n            }, this) : null\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 838,\n            columnNumber: 17\n          }, this), eventStatus.transcript && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `mini-transcript ${showGraphs ? 'fade-out' : ''}`,\n            children: /*#__PURE__*/_jsxDEV(\"p\", {\n              style: {\n                whiteSpace: 'pre-line'\n              },\n              children: eventStatus.transcript\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 853,\n              columnNumber: 19\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 852,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 790,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 785,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 756,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"zEDRueQEHqEdkdswZ7TO+qAJTnU=\", false, function () {\n  return [useSpeechRecognition];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","RetellWebClient","SplineLoader","SplineViewer","SpeechRecognition","useSpeechRecognition","agentIcon","userIcon","jsxDEV","_jsxDEV","Fragment","_Fragment","App","_s","splineInstanceRef","isCallActive","setIsCallActive","retellWebClient","setRetellWebClient","eventStatus","setEventStatus","callStarted","callEnded","agentStartTalking","agentStopTalking","error","transcript","micPermission","setMicPermission","accessToken","setAccessToken","isGeneratingToken","setIsGeneratingToken","callInfo","setCallInfo","loadingComplete","setLoadingComplete","showUI","setShowUI","splineInitialized","setSplineInitialized","animationTimerRef","lastKeyPressRef","keyPressedRef","showGraphs","setShowGraphs","graphType","setGraphType","graphTimerRef","messages","setMessages","isAgentSpeaking","setIsAgentSpeaking","setTranscript","graphKeywords","graphIntervalRef","messagesEndRef","currentTranscript","listening","resetTranscript","browserSupportsSpeechRecognition","KEY_PRESS_DURATION","AGENT_ID","TOKEN_SERVER_URL","checkForGraphKeywords","lowerText","toLowerCase","includes","handleGraphVisualization","shouldShowGraphs","graphTypes","randomType","Math","floor","random","length","current","clearInterval","setInterval","prevType","nextIndex","indexOf","simulateKeyPress","key","sendKeyDown","console","log","setTimeout","sendKeyUp","e","document","activeElement","event","KeyboardEvent","code","toUpperCase","keyCode","charCodeAt","which","bubbles","cancelable","composed","dispatchEvent","upEvent","buttonSelector","button","querySelector","classList","add","remove","splineContainer","iframe","iframeDoc","contentDocument","contentWindow","target","body","handleKeyDown","testAnimation","window","addEventListener","removeEventListener","startTalkingAnimation","wasNegation","hasNegation","stopTalkingAnimation","direction","client","checkMicrophonePermission","on","prev","update","role","content","Array","isArray","formattedTranscript","map","msg","String","join","metadata","message","stopCall","generateAccessToken","response","fetch","method","headers","JSON","stringify","agent_id","ok","errorData","json","Error","status","data","access_token","stream","navigator","mediaDevices","getUserMedia","audio","getTracks","forEach","track","stop","requestMicrophonePermission","startCall","permissionGranted","alert","token","sampleRate","captureDeviceId","emitRawAudioSamples","isTokenExpired","_tokenReceivedTime","Date","now","tokenReceivedTime","currentTime","tokenAgeInSeconds","handleLoadingComplete","renderGraph","className","children","style","height","fileName","_jsxFileName","lineNumber","columnNumber","viewBox","d","top","left","_messagesEndRef$curre","scrollIntoView","behavior","checkForGraphKeywordsSpeech","text","textLower","some","keyword","handleGraphVisualizationSpeech","hasGraphKeywords","handleStartListening","startListening","continuous","handleStopListening","stopListening","toggleAgentSpeaking","handleSendMessage","trim","newMessage","sender","timestamp","toISOString","renderAgentResponse","agentMessage","onLoadingComplete","ref","url","options","hint","persistOnUpdate","onClick","disabled","whiteSpace","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { RetellWebClient } from \"retell-client-js-sdk\";\nimport SplineLoader from './SplineLoader';\nimport SplineViewer from './SplineViewer';\nimport './index.css';\nimport SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';\nimport agentIcon from './assets/agent-icon.svg';\nimport userIcon from './assets/user-icon.svg';\n\nfunction App() {\n  // Add a ref to maintain the Spline instance\n  const splineInstanceRef = useRef(null);\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [retellWebClient, setRetellWebClient] = useState(null);\n  const [eventStatus, setEventStatus] = useState({\n    callStarted: false,\n    callEnded: false,\n    agentStartTalking: false,\n    agentStopTalking: false,\n    error: null,\n    transcript: ''\n  });\n  const [micPermission, setMicPermission] = useState(null);\n  const [accessToken, setAccessToken] = useState('');\n  const [isGeneratingToken, setIsGeneratingToken] = useState(false);\n  const [callInfo, setCallInfo] = useState(null);\n  const [loadingComplete, setLoadingComplete] = useState(false);\n  const [showUI, setShowUI] = useState(true);\n  // Add state to control the mounting/unmounting of Spline\n  const [splineInitialized, setSplineInitialized] = useState(false);\n  // Add refs for animation control\n  const animationTimerRef = useRef(null);\n  const lastKeyPressRef = useRef(null);\n  // Track if key is being pressed\n  const keyPressedRef = useRef({});\n  // State for graph visualization\n  const [showGraphs, setShowGraphs] = useState(false);\n  const [graphType, setGraphType] = useState('bar'); // 'bar', 'line', 'pie', 'scatter'\n  const graphTimerRef = useRef(null);\n  const [messages, setMessages] = useState([]);\n  const [isAgentSpeaking, setIsAgentSpeaking] = useState(false);\n  const [transcript, setTranscript] = useState('');\n  const graphKeywords = ['graph', 'chart', 'stats', 'data', 'visualization', 'metrics', 'numbers'];\n  const graphIntervalRef = useRef(null);\n  const messagesEndRef = useRef(null);\n\n  const {\n    transcript: currentTranscript,\n    listening,\n    resetTranscript,\n    browserSupportsSpeechRecognition\n  } = useSpeechRecognition();\n\n  // Key press duration in milliseconds (0.5 seconds)\n  const KEY_PRESS_DURATION = 500; \n\n  // Agent ID for Retell\n  const AGENT_ID = \"agent_90c352c3f8973e7127b472335e\";\n  \n  // Server endpoint for token generation\n  const TOKEN_SERVER_URL = \"http://127.0.0.1:5000/api/generate-token\";\n\n  // Function to check if the transcript contains data visualization keywords\n  const checkForGraphKeywords = (transcript) => {\n    if (!transcript) return false;\n    \n    const lowerText = transcript.toLowerCase();\n    return (\n      lowerText.includes('chart') || \n      lowerText.includes('graph') || \n      lowerText.includes('stats') ||\n      lowerText.includes('statistics') ||\n      lowerText.includes('visualization') ||\n      lowerText.includes('plot') ||\n      lowerText.includes('diagram')\n    );\n  };\n  \n  // Function to handle graph visualization\n  const handleGraphVisualization = (transcript) => {\n    const shouldShowGraphs = checkForGraphKeywords(transcript);\n    \n    if (shouldShowGraphs && !showGraphs) {\n      // Show graphs when keywords are detected\n      setShowGraphs(true);\n      \n      // Randomly select a graph type to display\n      const graphTypes = ['bar', 'line', 'pie', 'scatter'];\n      const randomType = graphTypes[Math.floor(Math.random() * graphTypes.length)];\n      setGraphType(randomType);\n      \n      // Cycle through graph types while keywords are present\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n      }\n      \n      graphTimerRef.current = setInterval(() => {\n        setGraphType(prevType => {\n          const nextIndex = (graphTypes.indexOf(prevType) + 1) % graphTypes.length;\n          return graphTypes[nextIndex];\n        });\n      }, 3000); // Change graph type every 3 seconds\n    } \n    else if (!shouldShowGraphs && showGraphs && !eventStatus.agentStartTalking) {\n      // Hide graphs when keywords are no longer detected and agent stops talking\n      setShowGraphs(false);\n      \n      // Clean up the timer\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n        graphTimerRef.current = null;\n      }\n    }\n  };\n\n  // Enhanced function to simulate a keyboard press with multiple methods\n  const simulateKeyPress = (key) => {\n    // Prevent rapid repeated presses\n    if (keyPressedRef.current[key]) return;\n    keyPressedRef.current[key] = true;\n    \n    // Method 1: Use our custom SplineViewer reference method if available\n    if (splineInstanceRef.current) {\n      try {\n        // Send keydown event\n        splineInstanceRef.current.sendKeyDown(key);\n        console.log(`Sent keydown to Spline via ref: ${key}`);\n        \n        // Schedule keyup after KEY_PRESS_DURATION\n        setTimeout(() => {\n          splineInstanceRef.current.sendKeyUp(key);\n          console.log(`Sent keyup to Spline via ref: ${key}`);\n        }, KEY_PRESS_DURATION);\n      } catch (e) {\n        console.error(\"Error using splineInstanceRef sendKey:\", e);\n      }\n    }\n    \n    // Method 2: Try to dispatch to active element (sometimes this works better)\n    try {\n      if (document.activeElement) {\n        const event = new KeyboardEvent('keydown', {\n          key: key,\n          code: `Key${key.toUpperCase()}`,\n          keyCode: key.charCodeAt(0),\n          which: key.charCodeAt(0),\n          bubbles: true,\n          cancelable: true,\n          composed: true\n        });\n        document.activeElement.dispatchEvent(event);\n        \n        // Schedule keyup after KEY_PRESS_DURATION\n        setTimeout(() => {\n          const upEvent = new KeyboardEvent('keyup', {\n            key: key,\n            code: `Key${key.toUpperCase()}`,\n            keyCode: key.charCodeAt(0),\n            which: key.charCodeAt(0),\n            bubbles: true,\n            cancelable: true,\n            composed: true\n          });\n          document.activeElement.dispatchEvent(upEvent);\n        }, KEY_PRESS_DURATION);\n      }\n    } catch (e) {\n      console.error(\"Error dispatching to active element:\", e);\n    }\n    \n    // Method 3: Manually activate the test buttons through DOM\n    try {\n      // Create a mouse click event on the corresponding test button\n      const buttonSelector = key === 'u' ? '.test-btn:nth-child(1)' : \n                             key === 'd' ? '.test-btn:nth-child(2)' : \n                             key === 'l' ? '.test-btn:nth-child(3)' : \n                             '.test-btn:nth-child(4)';\n                             \n      const button = document.querySelector(buttonSelector);\n      if (button) {\n        // Add active state with CSS\n        button.classList.add('active-test-btn');\n        \n        // Remove active state after KEY_PRESS_DURATION\n        setTimeout(() => {\n          button.classList.remove('active-test-btn');\n        }, KEY_PRESS_DURATION);\n      }\n    } catch (e) {\n      console.error(\"Error activating test button:\", e);\n    }\n    \n    // Method 4: Try to locate and interact directly with the Spline iframe\n    try {\n      const splineContainer = document.querySelector('.spline-container');\n      if (splineContainer) {\n        const iframe = splineContainer.querySelector('iframe');\n        if (iframe) {\n          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n          \n          // Try to find body or canvas element\n          const target = iframeDoc.querySelector('canvas') || iframeDoc.body || iframeDoc;\n          if (target) {\n            const event = new KeyboardEvent('keydown', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              which: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            target.dispatchEvent(event);\n            \n            // Schedule keyup after KEY_PRESS_DURATION\n            setTimeout(() => {\n              const upEvent = new KeyboardEvent('keyup', {\n                key: key,\n                code: `Key${key.toUpperCase()}`,\n                keyCode: key.charCodeAt(0),\n                which: key.charCodeAt(0),\n                bubbles: true,\n                cancelable: true\n              });\n              target.dispatchEvent(upEvent);\n            }, KEY_PRESS_DURATION);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(\"Error dispatching directly to iframe content:\", e);\n    }\n    \n    // Store the last key press\n    lastKeyPressRef.current = key;\n    \n    // Reset pressed state after KEY_PRESS_DURATION plus a small buffer\n    setTimeout(() => {\n      keyPressedRef.current[key] = false;\n    }, KEY_PRESS_DURATION + 100);\n  };\n\n  // Function to handle actual keyboard events (for testing purposes)\n  const handleKeyDown = (e) => {\n    // We'll only log and process the keys we're interested in\n    if (['u', 'd', 'l', 'r'].includes(e.key)) {\n      console.log(`Actual key press: ${e.key}`);\n      \n      // We should also manually trigger the same spline animation for consistent behavior\n      if (!keyPressedRef.current[e.key]) {\n        testAnimation(e.key);\n      }\n    }\n  };\n\n  // Add a hook to listen for real keyboard events for debugging\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n\n  // Function to start animation based on talking state\n  const startTalkingAnimation = () => {\n    // Clear any existing animation timer\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n    }\n    \n    // Reset the last key press to force starting with up movement\n    lastKeyPressRef.current = null;\n    \n    // Start with an initial up key press to ensure we begin with up/down\n    simulateKeyPress('u');\n    \n    // Track the previous negation state\n    let wasNegation = false;\n    \n    // Set up a new animation timer to simulate key presses while talking\n    // Use a longer interval to account for the longer key press duration\n    animationTimerRef.current = setInterval(() => {\n      // Check if the transcript contains negation words\n      const hasNegation = eventStatus.transcript && (\n        eventStatus.transcript.toLowerCase().includes('no') || \n        eventStatus.transcript.toLowerCase().includes('not') ||\n        eventStatus.transcript.toLowerCase().includes(\"don't\") ||\n        eventStatus.transcript.toLowerCase().includes(\"doesn't\")\n      );\n      \n      // If negation state changed from true to false, reset the animation pattern\n      if (wasNegation && !hasNegation) {\n        console.log(\"Negation ended, resetting to up/down movement\");\n        lastKeyPressRef.current = null;\n        simulateKeyPress('u');\n      }\n      \n      // Update the previous negation state\n      wasNegation = hasNegation;\n      \n      // If there's negation, use left-right movements\n      if (hasNegation) {\n        // Alternate between left and right\n        if (lastKeyPressRef.current === 'l') {\n          simulateKeyPress('r');\n        } else {\n          simulateKeyPress('l');\n        }\n      } else {\n        // Otherwise use up-down movements\n        if (lastKeyPressRef.current === 'u') {\n          simulateKeyPress('d');\n        } else {\n          simulateKeyPress('u');\n        }\n      }\n    }, KEY_PRESS_DURATION + 200); // Animation interval is longer to account for key press duration\n  };\n  \n  // Function to stop animation\n  const stopTalkingAnimation = () => {\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n      animationTimerRef.current = null;\n    }\n    \n    // If the agent stops talking, schedule hiding the graphs after a short delay\n    if (showGraphs) {\n      setTimeout(() => {\n        setShowGraphs(false);\n        \n        // Clean up the graph timer\n        if (graphTimerRef.current) {\n          clearInterval(graphTimerRef.current);\n          graphTimerRef.current = null;\n        }\n      }, 2000);\n    }\n  };\n\n  // Function to manually trigger animation for testing \n  const testAnimation = (direction) => {\n    simulateKeyPress(direction);\n  };\n\n  // Effect to update graph visualization when transcript changes\n  useEffect(() => {\n    if (eventStatus.transcript) {\n      handleGraphVisualization(eventStatus.transcript);\n    }\n  }, [eventStatus.transcript, eventStatus.agentStartTalking]);\n  \n  // Clean up graph timer on component unmount\n  useEffect(() => {\n    return () => {\n      if (graphTimerRef.current) {\n        clearInterval(graphTimerRef.current);\n        graphTimerRef.current = null;\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    // Initialize the RetellWebClient\n    const client = new RetellWebClient();\n    setRetellWebClient(client);\n    \n    // Check for microphone permissions\n    checkMicrophonePermission();\n    \n    // Set up event listeners\n    client.on(\"call_started\", () => {\n      console.log(\"call started\");\n      setEventStatus(prev => ({ ...prev, callStarted: true, callEnded: false }));\n    });\n\n    client.on(\"call_ended\", () => {\n      console.log(\"call ended\");\n      setIsCallActive(false);\n      setEventStatus(prev => ({ ...prev, callEnded: true }));\n      stopTalkingAnimation();\n    });\n\n    client.on(\"agent_start_talking\", () => {\n      console.log(\"agent_start_talking\");\n      setEventStatus(prev => ({ ...prev, agentStartTalking: true, agentStopTalking: false }));\n      startTalkingAnimation();\n    });\n\n    client.on(\"agent_stop_talking\", () => {\n      console.log(\"agent_stop_talking\");\n      setEventStatus(prev => ({ ...prev, agentStopTalking: true, agentStartTalking: false }));\n      stopTalkingAnimation();\n    });\n\n    client.on(\"update\", (update) => {\n      console.log(\"Update received:\", update);\n      if (update.transcript) {\n        // Check if transcript is an object with role and content properties\n        if (typeof update.transcript === 'object' && update.transcript.role && update.transcript.content) {\n          // Extract the content text\n          setEventStatus(prev => ({ ...prev, transcript: update.transcript.content }));\n        } \n        // Check if transcript is an array of message objects\n        else if (Array.isArray(update.transcript)) {\n          // Map through messages and format them\n          const formattedTranscript = update.transcript\n            .map(msg => {\n              if (typeof msg === 'object' && msg.role && msg.content) {\n                return `${msg.role}: ${msg.content}`;\n              }\n              return String(msg); // Convert to string if it's some other type\n            })\n            .join('\\n');\n          setEventStatus(prev => ({ ...prev, transcript: formattedTranscript }));\n        } \n        // If it's a string or can be converted to string\n        else {\n          setEventStatus(prev => ({ ...prev, transcript: String(update.transcript) }));\n        }\n      }\n    });\n\n    client.on(\"metadata\", (metadata) => {\n      console.log(\"Metadata received:\", metadata);\n    });\n\n    client.on(\"error\", (error) => {\n      console.error(\"An error occurred:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Unknown error\" }));\n      client.stopCall();\n      stopTalkingAnimation();\n    });\n    \n    // Clean up event listeners and animation on component unmount\n    return () => {\n      stopTalkingAnimation();\n      if (client) {\n        client.stopCall();\n      }\n    };\n  }, []);\n\n  // Effect to handle animation when talking state changes\n  useEffect(() => {\n    if (eventStatus.agentStartTalking && !eventStatus.agentStopTalking) {\n      startTalkingAnimation();\n    } else {\n      stopTalkingAnimation();\n    }\n  }, [eventStatus.agentStartTalking, eventStatus.agentStopTalking]);\n  \n  // Function to generate an access token from the server\n  const generateAccessToken = async () => {\n    try {\n      setIsGeneratingToken(true);\n      setEventStatus(prev => ({ ...prev, error: null }));\n      console.log(\"Requesting access token from server...\");\n      \n      // Make the API call to our server endpoint\n      const response = await fetch(TOKEN_SERVER_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          agent_id: AGENT_ID,\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `Server responded with status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      if (!data.access_token) {\n        throw new Error(\"No access token received from server\");\n      }\n      \n      console.log(\"Access token received from server:\", data.access_token);\n      setAccessToken(data.access_token);\n      setCallInfo(data); // Store the full call info for reference\n      setIsGeneratingToken(false);\n      \n      return data.access_token;\n    } catch (error) {\n      console.error(\"Failed to generate access token:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Failed to generate access token\" }));\n      setIsGeneratingToken(false);\n      return null;\n    }\n  };\n  \n  const checkMicrophonePermission = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      setMicPermission('granted');\n      // Stop the stream tracks immediately\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      console.error('Microphone permission denied:', error);\n      setMicPermission('denied');\n    }\n  };\n  \n  const requestMicrophonePermission = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({ audio: true });\n      setMicPermission('granted');\n      return true;\n    } catch (error) {\n      console.error('Failed to get microphone permission:', error);\n      setMicPermission('denied');\n      return false;\n    }\n  };\n  \n  const startCall = async () => {\n    if (!retellWebClient || isCallActive) return;\n    \n    // First ensure we have microphone permissions\n    if (micPermission !== 'granted') {\n      const permissionGranted = await requestMicrophonePermission();\n      if (!permissionGranted) {\n        alert('Microphone permission is required to start a call');\n        return;\n      }\n    }\n    \n    try {\n      // Reset event status\n      setEventStatus({\n        callStarted: false,\n        callEnded: false,\n        agentStartTalking: false,\n        agentStopTalking: false,\n        error: null,\n        transcript: ''\n      });\n      \n      // Ensure we have a valid token\n      if (!accessToken) {\n        const token = await generateAccessToken();\n        if (!token) {\n          throw new Error(\"Failed to generate a valid access token\");\n        }\n      }\n      \n      console.log(\"Starting call with access token...\");\n      \n      // Start the call using the access token\n      await retellWebClient.startCall({\n        accessToken: accessToken,\n        sampleRate: 24000,\n        captureDeviceId: \"default\",\n        emitRawAudioSamples: false,\n      });\n      \n      setIsCallActive(true);\n    } catch (error) {\n      console.error(\"Failed to start call:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Failed to start call\" }));\n    }\n  };\n  \n  const stopCall = () => {\n    if (retellWebClient && isCallActive) {\n      retellWebClient.stopCall();\n      setIsCallActive(false);\n    }\n  };\n  \n  // Function to check if token is expired (tokens are valid for 30 seconds)\n  const isTokenExpired = () => {\n    // If we don't have token info, consider it expired\n    if (!accessToken || !callInfo) return true;\n    \n    // Track when we received the token in our application\n    if (!callInfo._tokenReceivedTime) {\n      // If this is the first time checking, add a timestamp of when we received it\n      callInfo._tokenReceivedTime = Date.now();\n      setCallInfo({...callInfo}); // Update the state to save this timestamp\n      return false; // Token is fresh\n    }\n    \n    // Calculate how long ago we received the token\n    const tokenReceivedTime = callInfo._tokenReceivedTime;\n    const currentTime = Date.now();\n    const tokenAgeInSeconds = (currentTime - tokenReceivedTime) / 1000;\n    \n    // Token expires after 30 seconds, but we consider it expired at 25s\n    // to give us a buffer to generate a new one\n    return tokenAgeInSeconds > 25;\n  };\n  \n  // New function to handle loading completion and initialize Spline only once\n  const handleLoadingComplete = () => {\n    setLoadingComplete(true);\n    setSplineInitialized(true);\n  };\n\n  // Render functions for different graph types\n  const renderGraph = () => {\n    switch(graphType) {\n      case 'bar':\n        return (\n          <div className=\"neon-graph bar-graph\">\n            <div className=\"bar\" style={{ height: '60%' }}></div>\n            <div className=\"bar\" style={{ height: '80%' }}></div>\n            <div className=\"bar\" style={{ height: '40%' }}></div>\n            <div className=\"bar\" style={{ height: '90%' }}></div>\n            <div className=\"bar\" style={{ height: '65%' }}></div>\n          </div>\n        );\n      case 'line':\n        return (\n          <div className=\"neon-graph line-graph\">\n            <svg viewBox=\"0 0 100 50\">\n              <path d=\"M0,40 L20,30 L40,35 L60,15 L80,25 L100,10\" />\n            </svg>\n          </div>\n        );\n      case 'pie':\n        return (\n          <div className=\"neon-graph pie-graph\">\n            <div className=\"pie-slice slice1\"></div>\n            <div className=\"pie-slice slice2\"></div>\n            <div className=\"pie-slice slice3\"></div>\n          </div>\n        );\n      case 'scatter':\n        return (\n          <div className=\"neon-graph scatter-graph\">\n            <div className=\"dot\" style={{ top: '20%', left: '30%' }}></div>\n            <div className=\"dot\" style={{ top: '60%', left: '70%' }}></div>\n            <div className=\"dot\" style={{ top: '40%', left: '50%' }}></div>\n            <div className=\"dot\" style={{ top: '70%', left: '20%' }}></div>\n            <div className=\"dot\" style={{ top: '30%', left: '80%' }}></div>\n            <div className=\"dot\" style={{ top: '50%', left: '40%' }}></div>\n          </div>\n        );\n      default:\n        return null;\n    }\n  };\n\n  useEffect(() => {\n    setTranscript(currentTranscript);\n  }, [currentTranscript]);\n\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  // Function to check for graph-related keywords in the transcript\n  const checkForGraphKeywordsSpeech = (text) => {\n    if (!text) return false;\n    const textLower = text.toLowerCase();\n    return graphKeywords.some(keyword => textLower.includes(keyword));\n  };\n\n  // Function to handle graph visualization based on keywords and agent speaking status\n  const handleGraphVisualizationSpeech = () => {\n    const hasGraphKeywords = checkForGraphKeywordsSpeech(transcript);\n    \n    if (hasGraphKeywords && isAgentSpeaking) {\n      setShowGraphs(true);\n      \n      // Start cycling through graph types if not already cycling\n      if (!graphIntervalRef.current) {\n        graphIntervalRef.current = setInterval(() => {\n          setGraphType(prevType => {\n            switch (prevType) {\n              case 'bar': return 'line';\n              case 'line': return 'pie';\n              case 'pie': return 'scatter';\n              case 'scatter': return 'bar';\n              default: return 'bar';\n            }\n          });\n        }, 3000); // Change graph type every 3 seconds\n      }\n    } else if (!isAgentSpeaking && showGraphs) {\n      // Fade out graphs when agent stops speaking\n      setTimeout(() => {\n        setShowGraphs(false);\n        if (graphIntervalRef.current) {\n          clearInterval(graphIntervalRef.current);\n          graphIntervalRef.current = null;\n        }\n      }, 2000); // 2 second delay before hiding graphs\n    }\n  };\n\n  // Monitor for changes in transcript and agent speaking status\n  useEffect(() => {\n    handleGraphVisualizationSpeech();\n  }, [transcript, isAgentSpeaking]);\n\n  // Clean up interval on component unmount\n  useEffect(() => {\n    return () => {\n      if (graphIntervalRef.current) {\n        clearInterval(graphIntervalRef.current);\n      }\n    };\n  }, []);\n\n  const handleStartListening = () => {\n    resetTranscript();\n    SpeechRecognition.startListening({ continuous: true });\n  };\n\n  const handleStopListening = () => {\n    SpeechRecognition.stopListening();\n  };\n\n  const toggleAgentSpeaking = () => {\n    setIsAgentSpeaking(!isAgentSpeaking);\n  };\n\n  const handleSendMessage = () => {\n    if (transcript.trim() === '') return;\n\n    const newMessage = {\n      text: transcript,\n      sender: 'user',\n      timestamp: new Date().toISOString()\n    };\n\n    setMessages([...messages, newMessage]);\n    resetTranscript();\n  };\n\n  const renderAgentResponse = () => {\n    // Simulate agent responding\n    const agentMessage = {\n      text: \"I'm processing your request. Here are some interesting statistics and data visualizations that might help you understand the trends better.\",\n      sender: 'agent',\n      timestamp: new Date().toISOString()\n    };\n\n    setTimeout(() => {\n      setMessages([...messages, agentMessage]);\n      setIsAgentSpeaking(true);\n      \n      // Simulate agent finishing speaking after 5 seconds\n      setTimeout(() => {\n        setIsAgentSpeaking(false);\n      }, 5000);\n    }, 1000);\n  };\n\n  return (\n    <div className=\"App\">\n      {!loadingComplete ? (\n        <SplineLoader onLoadingComplete={handleLoadingComplete} />\n      ) : (\n        <>\n          {/* Main Spline Animation filling the entire viewport */}\n          <div className=\"spline-container\">\n            {/* Use splineInitialized to ensure it's only mounted once */}\n            {splineInitialized && (\n              <SplineViewer \n                ref={splineInstanceRef}\n                url=\"https://prod.spline.design/MLpQD4kA7Miyykt9/scene.splinecode\"\n                options={{\n                  hint: true,\n                  'loading-anim-type': 'spinner-small-dark'\n                }}\n                persistOnUpdate={true}\n              />\n            )}\n            \n            {/* Graph visualization overlay when detected in transcript */}\n            {showGraphs && (\n              <div className={`graph-overlay ${showGraphs ? 'visible' : ''}`}>\n                {renderGraph()}\n              </div>\n            )}\n          </div>\n          \n          {/* Minimal UI sidebar */}\n          <div className={`sidebar ${showUI ? 'open' : 'closed'} ${showGraphs ? 'fade-out' : ''}`}>\n            <div className=\"toggle-ui\" onClick={() => setShowUI(!showUI)}>\n              {showUI ? '×' : '≡'}\n            </div>\n            \n            <div className=\"sidebar-content\">\n              <h2>AI Voice</h2>\n              \n              <div className=\"status-indicator\">\n                <div className={`status-dot ${isCallActive ? 'active' : 'inactive'}`}></div>\n                <span>{isCallActive ? 'Connected' : 'Disconnected'}</span>\n              </div>\n              \n              {micPermission !== 'granted' && (\n                <button \n                  onClick={requestMicrophonePermission}\n                  className=\"btn-secondary btn-small\"\n                >\n                  Enable Mic\n                </button>\n              )}\n              \n              <div className=\"control-buttons\">\n                <button \n                  onClick={!accessToken || isTokenExpired() ? generateAccessToken : startCall} \n                  disabled={isCallActive || isGeneratingToken}\n                  className=\"btn-primary\"\n                >\n                  {!accessToken || isTokenExpired() \n                    ? \"Connect\" \n                    : isGeneratingToken \n                      ? \"...\" \n                      : \"Start\"}\n                </button>\n                \n                {isCallActive && (\n                  <button \n                    onClick={stopCall} \n                    className=\"btn-danger\"\n                  >\n                    End\n                  </button>\n                )}\n              </div>\n              \n              {eventStatus.error && (\n                <div className=\"error-badge\">\n                  Error: {eventStatus.error}\n                </div>\n              )}\n              \n              {/* Minimalistic talking indicator */}\n              {isCallActive && (\n                <div className={`talking-indicator ${showGraphs ? 'fade-out' : ''}`}>\n                  {eventStatus.agentStartTalking && !eventStatus.agentStopTalking ? (\n                    <div className=\"wave-animation\">\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                    </div>\n                  ) : null}\n                </div>\n              )}\n              \n              {/* Transcript in a minimal scrollable area */}\n              {eventStatus.transcript && (\n                <div className={`mini-transcript ${showGraphs ? 'fade-out' : ''}`}>\n                  <p style={{ whiteSpace: 'pre-line' }}>{eventStatus.transcript}</p>\n                </div>\n              )}\n            </div>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}