{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDirectionComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 640,\n  height: 480\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\n\n// Thresholds for determining direction\nconst DIRECTION_THRESHOLDS = {\n  LEFT: 30,\n  // Degrees for yaw to trigger left\n  RIGHT: 30,\n  // Degrees for yaw to trigger right\n  UP: 30,\n  // Degrees for tilt to trigger up\n  DOWN: 20,\n  // Degrees for tilt to trigger down\n  NEUTRAL_ZONE: 15,\n  // Degrees of center zone where no direction is triggered\n  // X-coordinate thresholds (pixels from center)\n  X_LEFT: 200,\n  // X < center - X_LEFT triggers left\n  X_RIGHT: 400 // X > center + X_RIGHT triggers right\n};\n\n// Cooldown between direction changes in milliseconds\nconst DIRECTION_COOLDOWN = 300;\nfunction FaceDirectionComponent({\n  onDirectionChange\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [facePosition, setFacePosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [currentDirection, setCurrentDirection] = useState(\"center\");\n  const lastDirectionTimeRef = useRef(Date.now());\n  const processingActiveRef = useRef(false);\n  const centerPositionRef = useRef({\n    x: inputResolution.width / 2,\n    y: inputResolution.height / 2\n  });\n\n  // Options for detector\n  const [options] = useState({\n    showMesh: false,\n    showTagNumbers: false,\n    showDirection: false\n  });\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      try {\n        // Ensure TensorFlow backend is ready\n        await window.tf.ready();\n        console.log(\"TensorFlow backend ready:\", window.tf.getBackend());\n        const faceDetector = new FaceDirectionDetector(options);\n        setDetector(faceDetector);\n      } catch (error) {\n        console.error(\"Error initializing face detector:\", error);\n      }\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n    };\n  }, [options]);\n\n  // Determine direction based on face position and angles\n  const determineDirection = data => {\n    if (!data || !data.keypoints || !data.keypoints[1]) {\n      return \"center\";\n    }\n    const now = Date.now();\n    // Check if we're still in cooldown period\n    if (now - lastDirectionTimeRef.current < DIRECTION_COOLDOWN) {\n      return currentDirection;\n    }\n    const {\n      yaw,\n      turn\n    } = data;\n    const noseX = data.keypoints[1].x;\n    const centerX = centerPositionRef.current.x;\n\n    // Determine horizontal direction (left/right)\n    // Use both yaw angle and X position\n    let newDirection = \"center\";\n\n    // First check based on absolute position\n    const xDiff = noseX - centerX;\n    if (xDiff < -DIRECTION_THRESHOLDS.X_LEFT) {\n      newDirection = \"left\";\n    } else if (xDiff > DIRECTION_THRESHOLDS.X_RIGHT) {\n      newDirection = \"right\";\n    } else if (yaw > DIRECTION_THRESHOLDS.RIGHT) {\n      // If X position isn't clear enough, use yaw as backup\n      newDirection = \"right\";\n    } else if (yaw < -DIRECTION_THRESHOLDS.LEFT) {\n      newDirection = \"left\";\n    }\n\n    // Turn affects up/down - this is approximate since the model doesn't directly give tilt\n    // We use the nose position relative to the face center\n    if (turn > DIRECTION_THRESHOLDS.UP) {\n      newDirection = \"up\";\n    } else if (turn < -DIRECTION_THRESHOLDS.DOWN) {\n      newDirection = \"down\";\n    }\n\n    // Only update if direction changed\n    if (newDirection !== currentDirection) {\n      lastDirectionTimeRef.current = now;\n      return newDirection;\n    }\n    return currentDirection;\n  };\n\n  // Map direction to key\n  const directionToKey = direction => {\n    switch (direction) {\n      case \"left\":\n        return \"l\";\n      case \"right\":\n        return \"r\";\n      case \"up\":\n        return \"u\";\n      case \"down\":\n        return \"d\";\n      default:\n        return null;\n    }\n  };\n\n  // Process video frames\n  const processVideo = async () => {\n    if (processingActiveRef.current || !detector || !webcamRef.current || !canvasRef.current) {\n      return;\n    }\n    try {\n      // Check if video is actually playing and has dimensions\n      const video = webcamRef.current.video;\n      if (!video || !video.readyState || video.readyState < 2 || video.videoWidth === 0 || video.videoHeight === 0) {\n        // Video not ready yet, retry later\n        setTimeout(processVideo, 100);\n        return;\n      }\n\n      // Mark as processing to prevent concurrent processing\n      processingActiveRef.current = true;\n\n      // Update center position reference based on actual video dimensions\n      centerPositionRef.current = {\n        x: video.videoWidth / 2,\n        y: video.videoHeight / 2\n      };\n\n      // Process with detector\n      await detector.start(video, canvasRef.current, data => {\n        // Extract face position from nose tip (keypoint 1)\n        if (data && data.keypoints && data.keypoints[1]) {\n          const newPos = {\n            x: Math.round(data.keypoints[1].x),\n            y: Math.round(data.keypoints[1].y)\n          };\n          setFacePosition(newPos);\n\n          // Determine direction\n          const newDirection = determineDirection(data);\n          if (newDirection !== currentDirection) {\n            setCurrentDirection(newDirection);\n\n            // Map direction to key\n            const key = directionToKey(newDirection);\n            if (key && onDirectionChange) {\n              onDirectionChange(key);\n            }\n          }\n        }\n\n        // Mark processing as completed\n        processingActiveRef.current = false;\n      });\n\n      // Set as loaded to prevent reinitialization\n      setLoaded(true);\n    } catch (error) {\n      console.error(\"Error processing video:\", error);\n      processingActiveRef.current = false;\n      // Retry after an error with a delay\n      setTimeout(processVideo, 1000);\n    }\n  };\n\n  // Handle video load\n  const handleVideoLoad = () => {\n    if (loaded) return;\n\n    // Start processing with a slight delay to ensure video is fully loaded\n    setTimeout(processVideo, 500);\n  };\n\n  // Effect to ensure cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      processingActiveRef.current = false;\n    };\n  }, [detector]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"face-direction-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        opacity: 0.1,\n        zIndex: 500,\n        pointerEvents: \"none\",\n        bottom: \"80px\",\n        right: \"20px\",\n        width: \"160px\",\n        height: \"120px\",\n        overflow: \"hidden\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        width: inputResolution.width,\n        height: inputResolution.height,\n        videoConstraints: videoConstraints,\n        onLoadedData: handleVideoLoad,\n        style: {\n          width: \"100%\",\n          height: \"100%\",\n          objectFit: \"cover\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 242,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        width: inputResolution.width,\n        height: inputResolution.height,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100%\",\n          height: \"100%\"\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 251,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"face-position-display\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"direction-indicator\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: `direction-arrow ${currentDirection}`,\n          children: currentDirection !== \"center\" && \"â†’\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 268,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"coordinates\",\n          children: [facePosition.x, \",\", facePosition.y]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 271,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 266,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 229,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceDirectionComponent, \"wbPjCE3zUhYkvfBuN06LvvScscI=\");\n_c = FaceDirectionComponent;\nexport default FaceDirectionComponent;\nvar _c;\n$RefreshReg$(_c, \"FaceDirectionComponent\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","DIRECTION_THRESHOLDS","LEFT","RIGHT","UP","DOWN","NEUTRAL_ZONE","X_LEFT","X_RIGHT","DIRECTION_COOLDOWN","FaceDirectionComponent","onDirectionChange","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","facePosition","setFacePosition","x","y","currentDirection","setCurrentDirection","lastDirectionTimeRef","Date","now","processingActiveRef","centerPositionRef","options","showMesh","showTagNumbers","showDirection","initializeDetector","window","tf","ready","console","log","getBackend","faceDetector","error","stop","determineDirection","data","keypoints","current","yaw","turn","noseX","centerX","newDirection","xDiff","directionToKey","direction","processVideo","video","readyState","videoWidth","videoHeight","setTimeout","start","newPos","Math","round","key","handleVideoLoad","className","children","style","position","opacity","zIndex","pointerEvents","bottom","right","overflow","ref","onLoadedData","objectFit","fileName","_jsxFileName","lineNumber","columnNumber","top","left","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDirectionComponent.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\r\nimport \"@tensorflow/tfjs\";\r\nimport \"@tensorflow/tfjs-backend-webgl\";\r\nimport Webcam from \"react-webcam\";\r\nimport FaceDirectionDetector from \"./FaceDirectionDetector\";\r\n\r\nconst inputResolution = {\r\n  width: 640,\r\n  height: 480,\r\n};\r\n\r\nconst videoConstraints = {\r\n  width: inputResolution.width,\r\n  height: inputResolution.height,\r\n  facingMode: \"user\",\r\n};\r\n\r\n// Thresholds for determining direction\r\nconst DIRECTION_THRESHOLDS = {\r\n  LEFT: 30,  // Degrees for yaw to trigger left\r\n  RIGHT: 30, // Degrees for yaw to trigger right\r\n  UP: 30,    // Degrees for tilt to trigger up\r\n  DOWN: 20,  // Degrees for tilt to trigger down\r\n  NEUTRAL_ZONE: 15, // Degrees of center zone where no direction is triggered\r\n  // X-coordinate thresholds (pixels from center)\r\n  X_LEFT: 200,  // X < center - X_LEFT triggers left\r\n  X_RIGHT: 400  // X > center + X_RIGHT triggers right\r\n};\r\n\r\n// Cooldown between direction changes in milliseconds\r\nconst DIRECTION_COOLDOWN = 300;\r\n\r\nfunction FaceDirectionComponent({ onDirectionChange }) {\r\n  const canvasRef = useRef(null);\r\n  const webcamRef = useRef(null);\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [detector, setDetector] = useState(null);\r\n  const [facePosition, setFacePosition] = useState({ x: 0, y: 0 });\r\n  const [currentDirection, setCurrentDirection] = useState(\"center\");\r\n  const lastDirectionTimeRef = useRef(Date.now());\r\n  const processingActiveRef = useRef(false);\r\n  const centerPositionRef = useRef({ x: inputResolution.width / 2, y: inputResolution.height / 2 });\r\n  \r\n  // Options for detector\r\n  const [options] = useState({\r\n    showMesh: false,\r\n    showTagNumbers: false,\r\n    showDirection: false\r\n  });\r\n\r\n  // Initialize the detector\r\n  useEffect(() => {\r\n    const initializeDetector = async () => {\r\n      try {\r\n        // Ensure TensorFlow backend is ready\r\n        await window.tf.ready();\r\n        console.log(\"TensorFlow backend ready:\", window.tf.getBackend());\r\n        \r\n        const faceDetector = new FaceDirectionDetector(options);\r\n        setDetector(faceDetector);\r\n      } catch (error) {\r\n        console.error(\"Error initializing face detector:\", error);\r\n      }\r\n    };\r\n\r\n    initializeDetector();\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (detector) {\r\n        detector.stop();\r\n      }\r\n    };\r\n  }, [options]);\r\n\r\n  // Determine direction based on face position and angles\r\n  const determineDirection = (data) => {\r\n    if (!data || !data.keypoints || !data.keypoints[1]) {\r\n      return \"center\";\r\n    }\r\n    \r\n    const now = Date.now();\r\n    // Check if we're still in cooldown period\r\n    if (now - lastDirectionTimeRef.current < DIRECTION_COOLDOWN) {\r\n      return currentDirection;\r\n    }\r\n    \r\n    const { yaw, turn } = data;\r\n    const noseX = data.keypoints[1].x;\r\n    const centerX = centerPositionRef.current.x;\r\n    \r\n    // Determine horizontal direction (left/right)\r\n    // Use both yaw angle and X position\r\n    let newDirection = \"center\";\r\n    \r\n    // First check based on absolute position\r\n    const xDiff = noseX - centerX;\r\n    \r\n    if (xDiff < -DIRECTION_THRESHOLDS.X_LEFT) {\r\n      newDirection = \"left\";\r\n    } else if (xDiff > DIRECTION_THRESHOLDS.X_RIGHT) {\r\n      newDirection = \"right\";\r\n    } else if (yaw > DIRECTION_THRESHOLDS.RIGHT) {\r\n      // If X position isn't clear enough, use yaw as backup\r\n      newDirection = \"right\";\r\n    } else if (yaw < -DIRECTION_THRESHOLDS.LEFT) {\r\n      newDirection = \"left\";\r\n    }\r\n    \r\n    // Turn affects up/down - this is approximate since the model doesn't directly give tilt\r\n    // We use the nose position relative to the face center\r\n    if (turn > DIRECTION_THRESHOLDS.UP) {\r\n      newDirection = \"up\";\r\n    } else if (turn < -DIRECTION_THRESHOLDS.DOWN) {\r\n      newDirection = \"down\";\r\n    }\r\n    \r\n    // Only update if direction changed\r\n    if (newDirection !== currentDirection) {\r\n      lastDirectionTimeRef.current = now;\r\n      return newDirection;\r\n    }\r\n    \r\n    return currentDirection;\r\n  };\r\n\r\n  // Map direction to key\r\n  const directionToKey = (direction) => {\r\n    switch (direction) {\r\n      case \"left\":\r\n        return \"l\";\r\n      case \"right\":\r\n        return \"r\"; \r\n      case \"up\":\r\n        return \"u\";\r\n      case \"down\":\r\n        return \"d\";\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  // Process video frames\r\n  const processVideo = async () => {\r\n    if (processingActiveRef.current || !detector || !webcamRef.current || !canvasRef.current) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Check if video is actually playing and has dimensions\r\n      const video = webcamRef.current.video;\r\n      \r\n      if (!video || !video.readyState || video.readyState < 2 || \r\n          video.videoWidth === 0 || video.videoHeight === 0) {\r\n        // Video not ready yet, retry later\r\n        setTimeout(processVideo, 100);\r\n        return;\r\n      }\r\n\r\n      // Mark as processing to prevent concurrent processing\r\n      processingActiveRef.current = true;\r\n      \r\n      // Update center position reference based on actual video dimensions\r\n      centerPositionRef.current = {\r\n        x: video.videoWidth / 2,\r\n        y: video.videoHeight / 2\r\n      };\r\n      \r\n      // Process with detector\r\n      await detector.start(\r\n        video,\r\n        canvasRef.current,\r\n        (data) => {\r\n          // Extract face position from nose tip (keypoint 1)\r\n          if (data && data.keypoints && data.keypoints[1]) {\r\n            const newPos = {\r\n              x: Math.round(data.keypoints[1].x),\r\n              y: Math.round(data.keypoints[1].y)\r\n            };\r\n            setFacePosition(newPos);\r\n            \r\n            // Determine direction\r\n            const newDirection = determineDirection(data);\r\n            if (newDirection !== currentDirection) {\r\n              setCurrentDirection(newDirection);\r\n              \r\n              // Map direction to key\r\n              const key = directionToKey(newDirection);\r\n              if (key && onDirectionChange) {\r\n                onDirectionChange(key);\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Mark processing as completed\r\n          processingActiveRef.current = false;\r\n        }\r\n      );\r\n      \r\n      // Set as loaded to prevent reinitialization\r\n      setLoaded(true);\r\n    } catch (error) {\r\n      console.error(\"Error processing video:\", error);\r\n      processingActiveRef.current = false;\r\n      // Retry after an error with a delay\r\n      setTimeout(processVideo, 1000);\r\n    }\r\n  };\r\n\r\n  // Handle video load\r\n  const handleVideoLoad = () => {\r\n    if (loaded) return;\r\n    \r\n    // Start processing with a slight delay to ensure video is fully loaded\r\n    setTimeout(processVideo, 500);\r\n  };\r\n\r\n  // Effect to ensure cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (detector) {\r\n        detector.stop();\r\n      }\r\n      processingActiveRef.current = false;\r\n    };\r\n  }, [detector]);\r\n\r\n  return (\r\n    <div className=\"face-direction-container\">\r\n      {/* Video and canvas for processing - now visible for debugging but transparent */}\r\n      <div style={{ \r\n        position: \"absolute\", \r\n        opacity: 0.1, \r\n        zIndex: 500,\r\n        pointerEvents: \"none\",\r\n        bottom: \"80px\",\r\n        right: \"20px\",\r\n        width: \"160px\",\r\n        height: \"120px\",\r\n        overflow: \"hidden\"\r\n      }}>\r\n        <Webcam\r\n          ref={webcamRef}\r\n          width={inputResolution.width}\r\n          height={inputResolution.height}\r\n          videoConstraints={videoConstraints}\r\n          onLoadedData={handleVideoLoad}\r\n          style={{ width: \"100%\", height: \"100%\", objectFit: \"cover\" }}\r\n        />\r\n        \r\n        <canvas\r\n          ref={canvasRef}\r\n          width={inputResolution.width}\r\n          height={inputResolution.height}\r\n          style={{ \r\n            position: \"absolute\", \r\n            top: 0, \r\n            left: 0,\r\n            width: \"100%\", \r\n            height: \"100%\"\r\n          }}\r\n        />\r\n      </div>\r\n\r\n      {/* Display current face position */}\r\n      <div className=\"face-position-display\">\r\n        <div className=\"direction-indicator\">\r\n          <div className={`direction-arrow ${currentDirection}`}>\r\n            {currentDirection !== \"center\" && \"â†’\"}\r\n          </div>\r\n          <div className=\"coordinates\">\r\n            {facePosition.x},{facePosition.y}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FaceDirectionComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}