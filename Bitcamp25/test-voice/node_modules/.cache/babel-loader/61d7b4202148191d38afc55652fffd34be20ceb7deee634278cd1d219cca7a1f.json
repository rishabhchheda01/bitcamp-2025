{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { slice } from './Slice';\nimport { CppDType } from './types';\nlet wasmSparseFillEmptyRows;\nexport function setup(backend) {\n  wasmSparseFillEmptyRows = backend.wasm.cwrap('SparseFillEmptyRows', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number' // exceptionValuesId\n  ]);\n}\nexport function sparseFillEmptyRows(args) {\n  const {\n    backend,\n    inputs\n  } = args;\n  const {\n    indices,\n    values,\n    denseShape,\n    defaultValue\n  } = inputs;\n  const indicesCount = indices.shape[0];\n  const rank = indices.shape[1];\n  const denseRows = backend.readSync(denseShape.dataId)[0];\n  // Set output size to maximum possible and resize later (actual result\n  // might be smaller).\n  const maxOutputIndicesShape = [indicesCount + denseRows, rank];\n  const indicesId = backend.dataIdMap.get(indices.dataId).id;\n  const valuesId = backend.dataIdMap.get(values.dataId).id;\n  const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;\n  const outputIndices = backend.makeOutput(maxOutputIndicesShape, indices.dtype);\n  const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;\n  const outputValues = backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);\n  const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;\n  const emptyRowIndicator = backend.makeOutput([denseRows], 'bool');\n  const emptyRowIndicatorId = backend.dataIdMap.get(emptyRowIndicator.dataId).id;\n  const reverseIndexMap = backend.makeOutput([indicesCount], indices.dtype);\n  const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;\n  const exceptionValues = backend.makeOutput([4], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n  const outputRows = wasmSparseFillEmptyRows(indicesId, valuesId, CppDType[values.dtype], indicesCount, denseRows, rank, defaultValueId, outputIndicesId, outputValuesId, emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);\n  const exceptionValuesArray = backend.readSync(exceptionValues.dataId);\n  let exceptionMessage;\n  switch (exceptionValuesArray[0]) {\n    case 1:\n      {\n        exceptionMessage = backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(exceptionValuesArray[1]);\n        break;\n      }\n    case 2:\n      {\n        exceptionMessage = backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);\n        break;\n      }\n    case 3:\n      exceptionMessage = backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);\n      break;\n    default:\n      exceptionMessage = '';\n  }\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n    backend.disposeData(emptyRowIndicator.dataId);\n    backend.disposeData(reverseIndexMap.dataId);\n    throw new Error(exceptionMessage);\n  }\n  let resizedIndices = outputIndices;\n  let resizedValues = outputValues;\n  // Overestimated output size.\n  if (outputRows !== maxOutputIndicesShape[0]) {\n    resizedIndices = slice({\n      inputs: {\n        x: outputIndices\n      },\n      attrs: {\n        begin: 0,\n        size: [outputRows, rank]\n      },\n      backend\n    });\n    resizedValues = slice({\n      inputs: {\n        x: outputValues\n      },\n      attrs: {\n        begin: 0,\n        size: outputRows\n      },\n      backend\n    });\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n  }\n  return [resizedIndices, resizedValues, emptyRowIndicator, reverseIndexMap];\n}\nexport const sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseFillEmptyRows\n};","map":{"version":3,"names":["backend_util","SparseFillEmptyRows","slice","CppDType","wasmSparseFillEmptyRows","setup","backend","wasm","cwrap","sparseFillEmptyRows","args","inputs","indices","values","denseShape","defaultValue","indicesCount","shape","rank","denseRows","readSync","dataId","maxOutputIndicesShape","indicesId","dataIdMap","get","id","valuesId","defaultValueId","outputIndices","makeOutput","dtype","outputIndicesId","outputValues","outputValuesId","emptyRowIndicator","emptyRowIndicatorId","reverseIndexMap","reverseIndexMapId","exceptionValues","exceptionValuesId","outputRows","exceptionValuesArray","exceptionMessage","getSparseFillEmptyRowsIndicesDenseShapeMismatch","getSparseFillEmptyRowsNegativeIndexErrorMessage","getSparseFillEmptyRowsOutOfRangeIndexErrorMessage","disposeData","Error","resizedIndices","resizedValues","x","attrs","begin","size","sparseFillEmptyRowsConfig","kernelName","backendName","setupFunc","kernelFunc"],"sources":["C:\\Users\\kheri\\Downloads\\Bitcamp\\bitcamp-2025\\Bitcamp25\\tfjs-backend-wasm\\src\\kernels\\SparseFillEmptyRows.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {slice} from './Slice';\n\nimport {CppDType} from './types';\n\nlet wasmSparseFillEmptyRows: (\n    indicesId: number, valuesId: number, valuesDType: number,\n    indicesCount: number, denseRows: number, rank: number,\n    defaultValueId: number, outputIndicesId: number, outputValuesId: number,\n    emptyRowIndicatorId: number, reverseIndexMapId: number,\n    exceptionValuesId: number) => number;\n\nexport function setup(backend: BackendWasm): void {\n  wasmSparseFillEmptyRows =\n      backend.wasm.cwrap('SparseFillEmptyRows', 'number', [\n        'number',  // indicesId\n        'number',  // valuesId\n        'number',  // valuesDType\n        'number',  // indicesCount\n        'number',  // denseRows\n        'number',  // rank\n        'number',  // defaultValueId\n        'number',  // outputIndicesId\n        'number',  // outputValuesId\n        'number',  // emptyRowIndicatorId\n        'number',  // reverseIndexMapId\n        'number',  // exceptionValuesId\n      ]);\n}\n\nexport function sparseFillEmptyRows(args: {\n  backend: BackendWasm,\n  inputs: SparseFillEmptyRowsInputs,\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {backend, inputs} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n\n  const indicesCount = indices.shape[0];\n  const rank = indices.shape[1];\n  const denseRows = backend.readSync(denseShape.dataId)[0] as number;\n\n  // Set output size to maximum possible and resize later (actual result\n  // might be smaller).\n  const maxOutputIndicesShape = [indicesCount + denseRows, rank];\n\n  const indicesId = backend.dataIdMap.get(indices.dataId).id;\n  const valuesId = backend.dataIdMap.get(values.dataId).id;\n  const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;\n\n  const outputIndices =\n      backend.makeOutput(maxOutputIndicesShape, indices.dtype);\n  const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;\n\n  const outputValues =\n      backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);\n  const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;\n\n  const emptyRowIndicator = backend.makeOutput([denseRows], 'bool');\n  const emptyRowIndicatorId =\n      backend.dataIdMap.get(emptyRowIndicator.dataId).id;\n\n  const reverseIndexMap = backend.makeOutput([indicesCount], indices.dtype);\n  const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;\n\n  const exceptionValues = backend.makeOutput([4], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n\n  const outputRows = wasmSparseFillEmptyRows(\n      indicesId, valuesId, CppDType[values.dtype], indicesCount, denseRows,\n      rank, defaultValueId, outputIndicesId, outputValuesId,\n      emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);\n\n  const exceptionValuesArray =\n      backend.readSync(exceptionValues.dataId) as Int32Array;\n\n  let exceptionMessage: string;\n  switch (exceptionValuesArray[0]) {\n    case 1: {\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(\n              exceptionValuesArray[1]);\n      break;\n    }\n    case 2: {\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2]);\n      break;\n    }\n    case 3:\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2],\n              exceptionValuesArray[3]);\n      break;\n    default:\n      exceptionMessage = '';\n  }\n\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n    backend.disposeData(emptyRowIndicator.dataId);\n    backend.disposeData(reverseIndexMap.dataId);\n    throw new Error(exceptionMessage);\n  }\n\n  let resizedIndices = outputIndices;\n  let resizedValues = outputValues;\n  // Overestimated output size.\n  if (outputRows !== maxOutputIndicesShape[0]) {\n    resizedIndices = slice({\n      inputs: {x: outputIndices},\n      attrs: {begin: 0, size: [outputRows, rank]},\n      backend\n    });\n    resizedValues = slice({\n      inputs: {x: outputValues},\n      attrs: {begin: 0, size: outputRows},\n      backend\n    });\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n  }\n\n  return [resizedIndices, resizedValues, emptyRowIndicator, reverseIndexMap];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseFillEmptyRows as unknown as KernelFunc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}