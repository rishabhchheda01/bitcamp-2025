{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n  const {\n    inputs: {\n      x\n    },\n    attrs: {\n      begin,\n      size\n    },\n    backend\n  } = args;\n  const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n  const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  const xVals = backend.readSync(x.dataId);\n  const out = backend.makeOutput(size_, x.dtype);\n  const xStrides = util.computeStrides(x.shape);\n  const outData = backend.dataIdMap.get(out.dataId);\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n    if (x.dtype === 'string') {\n      outData.stringBytes = xVals.slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      const outVals = backend.typedArrayFromHeap(out);\n      outVals.set(xVals.subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n    return out;\n  }\n  if (x.dtype === 'string') {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res;\n    return out;\n  }\n  const outVals = backend.typedArrayFromHeap(out);\n  const rank = x.shape.length;\n  if (rank === 2) {\n    slice2d(xVals, xStrides[0], outVals, begin_, size_);\n  } else if (rank === 3) {\n    slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n  } else if (rank === 4) {\n    slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n  } else {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outVals.set(res);\n  }\n  return out;\n}\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const endI = beginI + size[0];\n  for (let i = beginI; i < endI; i++) {\n    const xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      const xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  const endK = beginK + size[2];\n  const beginL = begin[3];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      for (let k = beginK; k < endK; k++) {\n        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\nexport const sliceConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice\n};","map":{"version":3,"names":["Slice","slice_util","util","sliceImplCPU","slice","args","inputs","x","attrs","begin","size","backend","begin_","size_","parseSliceParams","isContinous","isSliceContinous","shape","xVals","readSync","dataId","out","makeOutput","dtype","xStrides","computeStrides","outData","dataIdMap","get","flatOffset","computeFlatOffset","stringBytes","sizeFromShape","outVals","typedArrayFromHeap","set","subarray","res","rank","length","slice2d","slice3d","slice4d","xStride","outOffset","beginI","beginJ","endI","i","xOffset","xStride1","xStride2","beginK","endJ","j","xStride3","endK","beginL","k","sliceConfig","kernelName","backendName","kernelFunc"],"sources":["C:\\Users\\kheri\\Downloads\\Bitcamp\\bitcamp-2025\\Bitcamp25\\tfjs-backend-wasm\\src\\kernels\\Slice.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {sliceImplCPU} from '../kernel_utils/shared';\n\nexport function slice(\n    args: {inputs: SliceInputs, attrs: SliceAttrs, backend: BackendWasm}) {\n  const {inputs: {x}, attrs: {begin, size}, backend} = args;\n\n  const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n\n  const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  const xVals = backend.readSync(x.dataId);\n  const out = backend.makeOutput(size_, x.dtype);\n  const xStrides = util.computeStrides(x.shape);\n  const outData = backend.dataIdMap.get(out.dataId);\n\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n\n    if (x.dtype === 'string') {\n      outData.stringBytes =\n          (xVals as Uint8Array[])\n              .slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      const outVals = backend.typedArrayFromHeap(out);\n      outVals.set(\n          (xVals as TypedArray)\n              .subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n\n    return out;\n  }\n\n  if (x.dtype === 'string') {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res as Uint8Array[];\n    return out;\n  }\n\n  const outVals = backend.typedArrayFromHeap(out);\n  const rank = x.shape.length;\n  if (rank === 2) {\n    slice2d(\n        xVals as TypedArray, xStrides[0], outVals, begin_ as [number, number],\n        size_ as [number, number]);\n  } else if (rank === 3) {\n    slice3d(\n        xVals as TypedArray, xStrides[0], xStrides[1], outVals,\n        begin_ as [number, number, number], size_ as [number, number, number]);\n  } else if (rank === 4) {\n    slice4d(\n        xVals as TypedArray, xStrides[0], xStrides[1], xStrides[2], outVals,\n        begin_ as [number, number, number, number],\n        size_ as [number, number, number, number]);\n  } else {\n    const res =\n        sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype) as TypedArray;\n    outVals.set(res);\n  }\n\n  return out;\n}\n\nfunction slice2d(\n    xVals: backend_util.TypedArray, xStride: number,\n    outVals: backend_util.TypedArray, begin: [number, number],\n    size: [number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const endI = beginI + size[0];\n  for (let i = beginI; i < endI; i++) {\n    const xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\n\nfunction slice3d(\n    xVals: backend_util.TypedArray, xStride1: number, xStride2: number,\n    outVals: backend_util.TypedArray, begin: [number, number, number],\n    size: [number, number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      const xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\n\nfunction slice4d(\n    xVals: backend_util.TypedArray, xStride1: number, xStride2: number,\n    xStride3: number, outVals: backend_util.TypedArray,\n    begin: [number, number, number, number],\n    size: [number, number, number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  const endK = beginK + size[2];\n  const beginL = begin[3];\n\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      for (let k = beginK; k < endK; k++) {\n        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice as unknown as KernelFunc,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}