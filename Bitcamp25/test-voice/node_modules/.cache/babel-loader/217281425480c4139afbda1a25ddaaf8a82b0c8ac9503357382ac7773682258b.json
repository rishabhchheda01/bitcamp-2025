{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDetector.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport Webcam from 'react-webcam';\nimport { useFaceDetection } from 'react-use-face-detection';\nimport { FaceDetection } from '@mediapipe/face_detection';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FaceDetector = ({\n  onFacePositionChange,\n  isEnabled = true\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n\n  // Initialize face detection with MediaPipe\n  const {\n    boundingBox,\n    webcamRef: faceDetectionWebcamRef,\n    isLoading,\n    detected,\n    facesDetected\n  } = useFaceDetection({\n    faceDetectionOptions: {\n      model: 'short'\n    },\n    faceDetection: new FaceDetection({\n      locateFile: file => {\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;\n      }\n    }),\n    camera: ({\n      mediaSrc,\n      onFrame\n    }) => {\n      return new Camera(mediaSrc, {\n        onFrame,\n        width: 640,\n        height: 480\n      });\n    }\n  });\n\n  // Set webcam reference from face detection hook to our ref\n  useEffect(() => {\n    webcamRef.current = faceDetectionWebcamRef.current;\n  }, [faceDetectionWebcamRef]);\n\n  // Process bounding box data to determine face position\n  useEffect(() => {\n    if (!isEnabled || !detected || boundingBox.length === 0) return;\n\n    // We'll use the first detected face\n    const face = boundingBox[0];\n\n    // Calculate the center of the face\n    const centerX = face.topLeft[0] + (face.bottomRight[0] - face.topLeft[0]) / 2;\n    const centerY = face.topLeft[1] + (face.bottomRight[1] - face.topLeft[1]) / 2;\n\n    // Calculate position relative to the webcam dimensions (as percentage)\n    const relativeX = centerX / 640; // Assuming 640 width\n    const relativeY = centerY / 480; // Assuming 480 height\n\n    // Determine which direction to move based on face position\n    // We divide the screen into sections for simplicity\n    let direction = null;\n\n    // Horizontal position (left/right)\n    if (relativeX < 0.4) {\n      direction = 'l'; // Move left when face is on the right side\n    } else if (relativeX > 0.6) {\n      direction = 'r'; // Move right when face is on the left side\n    }\n    // Vertical position (up/down) - only if horizontal is not active\n    else if (relativeY < 0.4) {\n      direction = 'u'; // Move up when face is low\n    } else if (relativeY > 0.6) {\n      direction = 'd'; // Move down when face is high\n    }\n\n    // Call the callback with the direction if set\n    if (direction && onFacePositionChange) {\n      onFacePositionChange(direction, {\n        x: relativeX,\n        y: relativeY\n      });\n    }\n  }, [boundingBox, detected, isEnabled, onFacePositionChange]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `face-detector ${isEnabled ? 'active' : 'inactive'}`,\n    children: isEnabled && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative'\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: faceDetectionWebcamRef,\n        className: \"face-detection-webcam\",\n        mirrored: true,\n        screenshotFormat: \"image/jpeg\",\n        style: {\n          width: '100%',\n          height: 'auto',\n          maxWidth: '200px',\n          borderRadius: '8px',\n          opacity: 0.8\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 76,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"detection-status\",\n        children: isLoading ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator loading\",\n          children: \"Loading model...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 92,\n          columnNumber: 15\n        }, this) : detected ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator detected\",\n          children: [facesDetected, \" face\", facesDetected !== 1 ? 's' : '', \" detected\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 94,\n          columnNumber: 15\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator not-detected\",\n          children: \"No faces detected\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 98,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 90,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"bounding-box-visualization\",\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        },\n        children: boundingBox.map((box, index) => /*#__PURE__*/_jsxDEV(\"rect\", {\n          x: `${box.topLeft[0] / 640 * 100}%`,\n          y: `${box.topLeft[1] / 480 * 100}%`,\n          width: `${(box.bottomRight[0] - box.topLeft[0]) / 640 * 100}%`,\n          height: `${(box.bottomRight[1] - box.topLeft[1]) / 480 * 100}%`,\n          stroke: \"#00FFFF\",\n          strokeWidth: \"2\",\n          fill: \"none\"\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 113,\n          columnNumber: 15\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 102,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 73,\n    columnNumber: 5\n  }, this);\n};\n_s(FaceDetector, \"iqn7T2bw+O3l2jKg1tKxPLQzsTE=\", false, function () {\n  return [useFaceDetection];\n});\n_c = FaceDetector;\nexport default FaceDetector;\nvar _c;\n$RefreshReg$(_c, \"FaceDetector\");","map":{"version":3,"names":["React","useEffect","useRef","Webcam","useFaceDetection","FaceDetection","Camera","jsxDEV","_jsxDEV","FaceDetector","onFacePositionChange","isEnabled","_s","webcamRef","boundingBox","faceDetectionWebcamRef","isLoading","detected","facesDetected","faceDetectionOptions","model","faceDetection","locateFile","file","camera","mediaSrc","onFrame","width","height","current","length","face","centerX","topLeft","bottomRight","centerY","relativeX","relativeY","direction","x","y","className","children","style","position","ref","mirrored","screenshotFormat","maxWidth","borderRadius","opacity","fileName","_jsxFileName","lineNumber","columnNumber","top","left","map","box","index","stroke","strokeWidth","fill","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDetector.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { useFaceDetection } from 'react-use-face-detection';\r\nimport { FaceDetection } from '@mediapipe/face_detection';\r\nimport { Camera } from '@mediapipe/camera_utils';\r\n\r\nconst FaceDetector = ({ onFacePositionChange, isEnabled = true }) => {\r\n  const webcamRef = useRef(null);\r\n  \r\n  // Initialize face detection with MediaPipe\r\n  const { boundingBox, webcamRef: faceDetectionWebcamRef, isLoading, detected, facesDetected } = useFaceDetection({\r\n    faceDetectionOptions: {\r\n      model: 'short',\r\n    },\r\n    faceDetection: new FaceDetection({\r\n      locateFile: (file) => {\r\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;\r\n      }\r\n    }),\r\n    camera: ({ mediaSrc, onFrame }) => {\r\n      return new Camera(mediaSrc, {\r\n        onFrame,\r\n        width: 640,\r\n        height: 480,\r\n      });\r\n    },\r\n  });\r\n\r\n  // Set webcam reference from face detection hook to our ref\r\n  useEffect(() => {\r\n    webcamRef.current = faceDetectionWebcamRef.current;\r\n  }, [faceDetectionWebcamRef]);\r\n\r\n  // Process bounding box data to determine face position\r\n  useEffect(() => {\r\n    if (!isEnabled || !detected || boundingBox.length === 0) return;\r\n\r\n    // We'll use the first detected face\r\n    const face = boundingBox[0];\r\n    \r\n    // Calculate the center of the face\r\n    const centerX = face.topLeft[0] + (face.bottomRight[0] - face.topLeft[0]) / 2;\r\n    const centerY = face.topLeft[1] + (face.bottomRight[1] - face.topLeft[1]) / 2;\r\n    \r\n    // Calculate position relative to the webcam dimensions (as percentage)\r\n    const relativeX = centerX / 640; // Assuming 640 width\r\n    const relativeY = centerY / 480; // Assuming 480 height\r\n    \r\n    // Determine which direction to move based on face position\r\n    // We divide the screen into sections for simplicity\r\n    let direction = null;\r\n    \r\n    // Horizontal position (left/right)\r\n    if (relativeX < 0.4) {\r\n      direction = 'l'; // Move left when face is on the right side\r\n    } else if (relativeX > 0.6) {\r\n      direction = 'r'; // Move right when face is on the left side\r\n    }\r\n    // Vertical position (up/down) - only if horizontal is not active\r\n    else if (relativeY < 0.4) {\r\n      direction = 'u'; // Move up when face is low\r\n    } else if (relativeY > 0.6) {\r\n      direction = 'd'; // Move down when face is high\r\n    }\r\n    \r\n    // Call the callback with the direction if set\r\n    if (direction && onFacePositionChange) {\r\n      onFacePositionChange(direction, { x: relativeX, y: relativeY });\r\n    }\r\n  }, [boundingBox, detected, isEnabled, onFacePositionChange]);\r\n\r\n  return (\r\n    <div className={`face-detector ${isEnabled ? 'active' : 'inactive'}`}>\r\n      {isEnabled && (\r\n        <div style={{ position: 'relative' }}>\r\n          <Webcam\r\n            ref={faceDetectionWebcamRef}\r\n            className=\"face-detection-webcam\"\r\n            mirrored={true}\r\n            screenshotFormat=\"image/jpeg\"\r\n            style={{\r\n              width: '100%',\r\n              height: 'auto',\r\n              maxWidth: '200px',\r\n              borderRadius: '8px',\r\n              opacity: 0.8,\r\n            }}\r\n          />\r\n          {/* Face detection status indicator */}\r\n          <div className=\"detection-status\">\r\n            {isLoading ? (\r\n              <div className=\"status-indicator loading\">Loading model...</div>\r\n            ) : detected ? (\r\n              <div className=\"status-indicator detected\">\r\n                {facesDetected} face{facesDetected !== 1 ? 's' : ''} detected\r\n              </div>\r\n            ) : (\r\n              <div className=\"status-indicator not-detected\">No faces detected</div>\r\n            )}\r\n          </div>\r\n          {/* Debug visualization of bounding boxes */}\r\n          <svg\r\n            className=\"bounding-box-visualization\"\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n            }}\r\n          >\r\n            {boundingBox.map((box, index) => (\r\n              <rect\r\n                key={index}\r\n                x={`${box.topLeft[0] / 640 * 100}%`}\r\n                y={`${box.topLeft[1] / 480 * 100}%`}\r\n                width={`${(box.bottomRight[0] - box.topLeft[0]) / 640 * 100}%`}\r\n                height={`${(box.bottomRight[1] - box.topLeft[1]) / 480 * 100}%`}\r\n                stroke=\"#00FFFF\"\r\n                strokeWidth=\"2\"\r\n                fill=\"none\"\r\n              />\r\n            ))}\r\n          </svg>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default FaceDetector; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}