{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDirectionComponent.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst inputResolution = {\n  width: 640,\n  height: 480\n};\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\"\n};\nfunction FaceDirectionComponent() {\n  _s();\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [faceData, setFaceData] = useState({\n    position: {\n      x: 0,\n      y: 0\n    },\n    direction: {\n      yaw: 0,\n      turn: 0\n    },\n    horizontalDirection: \"center\",\n    verticalDirection: \"center\"\n  });\n  const lastDirectionRef = useRef({\n    horizontal: \"center\",\n    vertical: \"center\"\n  });\n  const keyPressTimerRef = useRef(null);\n  const sequenceTimerRef = useRef(null);\n  const [isSidebarOpen, setIsSidebarOpen] = useState(true);\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: false,\n        showTagNumbers: false,\n        showDirection: false\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      // Clear any active timers\n      if (keyPressTimerRef.current) {\n        clearInterval(keyPressTimerRef.current);\n      }\n      if (sequenceTimerRef.current) {\n        clearTimeout(sequenceTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Check sidebar state - run once on component mount and then on any DOM changes\n  useEffect(() => {\n    // Function to check if sidebar is open\n    const checkSidebar = () => {\n      const sidebar = document.querySelector('.sidebar');\n      if (sidebar) {\n        const isOpen = sidebar.classList.contains('open');\n        setIsSidebarOpen(isOpen);\n      }\n    };\n\n    // Initial check\n    checkSidebar();\n\n    // Set up a MutationObserver to watch for changes to the sidebar class\n    const observer = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          checkSidebar();\n        }\n      });\n    });\n\n    // Start observing the sidebar\n    const sidebar = document.querySelector('.sidebar');\n    if (sidebar) {\n      observer.observe(sidebar, {\n        attributes: true\n      });\n    }\n\n    // Clean up the observer on component unmount\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  // Determine horizontal direction based on x coordinate\n  const determineHorizontalDirection = x => {\n    if (x < 250) {\n      return \"left\";\n    } else if (x > 450) {\n      return \"right\";\n    } else {\n      return \"center\";\n    }\n  };\n\n  // Determine vertical direction based on y coordinate\n  const determineVerticalDirection = y => {\n    if (y < 200) {\n      return \"up\";\n    } else if (y > 350) {\n      return \"down\";\n    } else {\n      return \"center\";\n    }\n  };\n\n  // Simulate keyboard press for regular keys\n  const simulateKeyPress = key => {\n    try {\n      // Create keydown event\n      const keyDownEvent = new KeyboardEvent('keydown', {\n        key: key,\n        code: `Key${key.toUpperCase()}`,\n        keyCode: key.charCodeAt(0),\n        which: key.charCodeAt(0),\n        bubbles: true,\n        cancelable: true\n      });\n\n      // Dispatch the event\n      document.dispatchEvent(keyDownEvent);\n\n      // Log the key press\n      console.log(`Key ${key} pressed based on face direction`);\n\n      // Create and dispatch keyup event after a short delay\n      setTimeout(() => {\n        const keyUpEvent = new KeyboardEvent('keyup', {\n          key: key,\n          code: `Key${key.toUpperCase()}`,\n          keyCode: key.charCodeAt(0),\n          which: key.charCodeAt(0),\n          bubbles: true,\n          cancelable: true\n        });\n        document.dispatchEvent(keyUpEvent);\n      }, 100);\n    } catch (error) {\n      console.error(\"Error simulating key press:\", error);\n    }\n  };\n\n  // Simulate arrow key press\n  const simulateArrowKeyPress = direction => {\n    try {\n      // Map direction to arrow key\n      const arrowKey = direction === 'left' ? 'ArrowLeft' : direction === 'right' ? 'ArrowRight' : direction === 'up' ? 'ArrowUp' : 'ArrowDown';\n\n      // Create keydown event for arrow key\n      const keyDownEvent = new KeyboardEvent('keydown', {\n        key: arrowKey,\n        code: arrowKey,\n        keyCode: arrowKey === 'ArrowLeft' ? 37 : arrowKey === 'ArrowUp' ? 38 : arrowKey === 'ArrowRight' ? 39 : 40,\n        which: arrowKey === 'ArrowLeft' ? 37 : arrowKey === 'ArrowUp' ? 38 : arrowKey === 'ArrowRight' ? 39 : 40,\n        bubbles: true,\n        cancelable: true\n      });\n\n      // Dispatch the event\n      document.dispatchEvent(keyDownEvent);\n\n      // Log the key press\n      console.log(`Arrow key ${arrowKey} pressed based on face direction`);\n\n      // Create and dispatch keyup event after a short delay\n      setTimeout(() => {\n        const keyUpEvent = new KeyboardEvent('keyup', {\n          key: arrowKey,\n          code: arrowKey,\n          keyCode: arrowKey === 'ArrowLeft' ? 37 : arrowKey === 'ArrowUp' ? 38 : arrowKey === 'ArrowRight' ? 39 : 40,\n          which: arrowKey === 'ArrowLeft' ? 37 : arrowKey === 'ArrowUp' ? 38 : arrowKey === 'ArrowRight' ? 39 : 40,\n          bubbles: true,\n          cancelable: true\n        });\n        document.dispatchEvent(keyUpEvent);\n      }, 100);\n    } catch (error) {\n      console.error(`Error simulating arrow key press for ${direction}:`, error);\n    }\n  };\n\n  // Get key for direction\n  const getKeyForDirection = (horizontalDir, verticalDir) => {\n    if (horizontalDir === \"left\") return 'l';\n    if (horizontalDir === \"right\") return 'r';\n    if (verticalDir === \"up\") return 'u';\n    if (verticalDir === \"down\") return 'd';\n    return null;\n  };\n\n  // Handle sequential key presses for multiple directions\n  const handleDirectionChanges = () => {\n    // Clear any existing timer\n    if (keyPressTimerRef.current) {\n      clearInterval(keyPressTimerRef.current);\n      keyPressTimerRef.current = null;\n    }\n    if (sequenceTimerRef.current) {\n      clearTimeout(sequenceTimerRef.current);\n      sequenceTimerRef.current = null;\n    }\n\n    // Check if we have any direction to handle\n    const horizontalDir = faceData.horizontalDirection;\n    const verticalDir = faceData.verticalDirection;\n\n    // Store current directions to ref for next comparison\n    lastDirectionRef.current = {\n      horizontal: horizontalDir,\n      vertical: verticalDir\n    };\n\n    // Determine if we need to handle multiple directions sequentially\n    const hasHorizontalMovement = horizontalDir !== \"center\";\n    const hasVerticalMovement = verticalDir !== \"center\";\n\n    // First handle horizontal direction if it's not center\n    if (hasHorizontalMovement) {\n      const horizontalKey = horizontalDir === \"left\" ? 'l' : 'r';\n\n      // Press both the letter key and the arrow key\n      simulateKeyPress(horizontalKey);\n      simulateArrowKeyPress(horizontalDir);\n\n      // Set up interval for continuous horizontal key presses\n      keyPressTimerRef.current = setInterval(() => {\n        simulateKeyPress(horizontalKey);\n        simulateArrowKeyPress(horizontalDir);\n      }, 300);\n\n      // If we also have vertical movement, handle it after horizontal\n      if (hasVerticalMovement) {\n        // After 1 second, switch to vertical direction\n        sequenceTimerRef.current = setTimeout(() => {\n          // Stop horizontal key presses\n          if (keyPressTimerRef.current) {\n            clearInterval(keyPressTimerRef.current);\n            keyPressTimerRef.current = null;\n          }\n\n          // Start vertical key presses\n          const verticalKey = verticalDir === \"up\" ? 'u' : 'd';\n          simulateKeyPress(verticalKey);\n          simulateArrowKeyPress(verticalDir);\n          keyPressTimerRef.current = setInterval(() => {\n            simulateKeyPress(verticalKey);\n            simulateArrowKeyPress(verticalDir);\n          }, 300);\n        }, 300); // 1 second delay before switching directions\n      }\n    }\n    // If only vertical direction is detected, handle it immediately\n    else if (hasVerticalMovement) {\n      const verticalKey = verticalDir === \"up\" ? 'u' : 'd';\n\n      // Press both the letter key and the arrow key\n      simulateKeyPress(verticalKey);\n      simulateArrowKeyPress(verticalDir);\n\n      // Set up interval for continuous vertical key presses\n      keyPressTimerRef.current = setInterval(() => {\n        simulateKeyPress(verticalKey);\n        simulateArrowKeyPress(verticalDir);\n      }, 300);\n    }\n    // If neither direction is active, do nothing (center position)\n  };\n\n  // Effect to handle direction changes and trigger key presses\n  useEffect(() => {\n    // Check if either direction has changed\n    if (faceData.horizontalDirection !== lastDirectionRef.current.horizontal || faceData.verticalDirection !== lastDirectionRef.current.vertical) {\n      handleDirectionChanges();\n    }\n  }, [faceData.horizontalDirection, faceData.verticalDirection]);\n\n  // Handle video load\n  const handleVideoLoad = async videoNode => {\n    const video = videoNode.target;\n    if (video.readyState !== 4) return;\n    if (loaded) return;\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(webcamRef.current.video, canvasRef.current, data => {\n        // Update face data when detection occurs\n        if (data && data.keypoints && data.keypoints[1]) {\n          const x = Math.round(data.keypoints[1].x);\n          const y = Math.round(data.keypoints[1].y);\n          const horizontalDirection = determineHorizontalDirection(x);\n          const verticalDirection = determineVerticalDirection(y);\n          setFaceData({\n            position: {\n              x,\n              y\n            },\n            direction: {\n              yaw: Math.round(data.yaw || 0),\n              turn: Math.round(data.turn || 0)\n            },\n            horizontalDirection,\n            verticalDirection\n          });\n        }\n      });\n      setLoaded(true);\n    }\n  };\n\n  // Helper function to get active key display text\n  const getActiveKeyText = () => {\n    const {\n      horizontalDirection,\n      verticalDirection\n    } = faceData;\n    const hasHorizontal = horizontalDirection !== \"center\";\n    const hasVertical = verticalDirection !== \"center\";\n    if (hasHorizontal && hasVertical) {\n      const hKey = horizontalDirection === \"left\" ? \"'l' + ←\" : \"'r' + →\";\n      const vKey = verticalDirection === \"up\" ? \"'u' + ↑\" : \"'d' + ↓\";\n      return ``;\n    } else if (hasHorizontal) {\n      const hKey = horizontalDirection === \"left\" ? \"'l' + ←\" : \"'r' + →\";\n      return ``;\n    } else if (hasVertical) {\n      const vKey = verticalDirection === \"up\" ? \"'u' + ↑\" : \"'d' + ↓\";\n      return `(pressing ${vKey})`;\n    } else {\n      return \"(no key press)\";\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        visibility: \"hidden\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: webcamRef,\n        width: inputResolution.width,\n        height: inputResolution.height,\n        videoConstraints: videoConstraints,\n        onLoadedData: handleVideoLoad\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 365,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        width: inputResolution.width,\n        height: inputResolution.height\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 373,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 364,\n      columnNumber: 7\n    }, this), !isSidebarOpen && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        bottom: \"20px\",\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n        color: \"#00f2fe\",\n        padding: \"8px 16px\",\n        borderRadius: \"8px\",\n        fontFamily: \"monospace\",\n        fontSize: \"14px\",\n        zIndex: 1000,\n        display: \"flex\",\n        gap: \"16px\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Position: x=\", faceData.position.x, \", y=\", faceData.position.y]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 397,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Direction: H:\", faceData.horizontalDirection.toUpperCase(), \" V:\", faceData.verticalDirection.toUpperCase(), \" \", getActiveKeyText()]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 400,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Angles: yaw=\", faceData.direction.yaw, \"\\xB0, turn=\", faceData.direction.turn, \"\\xB0\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 403,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 382,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 362,\n    columnNumber: 5\n  }, this);\n}\n_s(FaceDirectionComponent, \"S+lCl0NZeYKe054vW8miEEYW0yY=\");\n_c = FaceDirectionComponent;\nexport default FaceDirectionComponent;\nvar _c;\n$RefreshReg$(_c, \"FaceDirectionComponent\");","map":{"version":3,"names":["React","useRef","useState","useEffect","Webcam","FaceDirectionDetector","jsxDEV","_jsxDEV","inputResolution","width","height","videoConstraints","facingMode","FaceDirectionComponent","_s","canvasRef","webcamRef","loaded","setLoaded","detector","setDetector","faceData","setFaceData","position","x","y","direction","yaw","turn","horizontalDirection","verticalDirection","lastDirectionRef","horizontal","vertical","keyPressTimerRef","sequenceTimerRef","isSidebarOpen","setIsSidebarOpen","initializeDetector","options","showMesh","showTagNumbers","showDirection","faceDetector","stop","current","clearInterval","clearTimeout","checkSidebar","sidebar","document","querySelector","isOpen","classList","contains","observer","MutationObserver","mutations","forEach","mutation","type","attributeName","observe","attributes","disconnect","determineHorizontalDirection","determineVerticalDirection","simulateKeyPress","key","keyDownEvent","KeyboardEvent","code","toUpperCase","keyCode","charCodeAt","which","bubbles","cancelable","dispatchEvent","console","log","setTimeout","keyUpEvent","error","simulateArrowKeyPress","arrowKey","getKeyForDirection","horizontalDir","verticalDir","handleDirectionChanges","hasHorizontalMovement","hasVerticalMovement","horizontalKey","setInterval","verticalKey","handleVideoLoad","videoNode","video","target","readyState","start","data","keypoints","Math","round","getActiveKeyText","hasHorizontal","hasVertical","hKey","vKey","children","style","visibility","ref","onLoadedData","fileName","_jsxFileName","lineNumber","columnNumber","bottom","left","transform","backgroundColor","color","padding","borderRadius","fontFamily","fontSize","zIndex","display","gap","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDirectionComponent.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from \"react\";\nimport \"@tensorflow/tfjs\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@mediapipe/face_mesh\";\nimport Webcam from \"react-webcam\";\nimport FaceDirectionDetector from \"./face_detection/FaceDirectionDetector\";\n\nconst inputResolution = {\n  width: 640,\n  height: 480,\n};\n\nconst videoConstraints = {\n  width: inputResolution.width,\n  height: inputResolution.height,\n  facingMode: \"user\",\n};\n\nfunction FaceDirectionComponent() {\n  const canvasRef = useRef(null);\n  const webcamRef = useRef(null);\n  const [loaded, setLoaded] = useState(false);\n  const [detector, setDetector] = useState(null);\n  const [faceData, setFaceData] = useState({\n    position: { x: 0, y: 0 },\n    direction: { yaw: 0, turn: 0 },\n    horizontalDirection: \"center\",\n    verticalDirection: \"center\"\n  });\n  const lastDirectionRef = useRef({ horizontal: \"center\", vertical: \"center\" });\n  const keyPressTimerRef = useRef(null);\n  const sequenceTimerRef = useRef(null);\n  const [isSidebarOpen, setIsSidebarOpen] = useState(true);\n\n  // Initialize the detector\n  useEffect(() => {\n    const initializeDetector = async () => {\n      const options = {\n        showMesh: false,\n        showTagNumbers: false,\n        showDirection: false\n      };\n      const faceDetector = new FaceDirectionDetector(options);\n      setDetector(faceDetector);\n    };\n\n    initializeDetector();\n\n    // Cleanup on unmount\n    return () => {\n      if (detector) {\n        detector.stop();\n      }\n      // Clear any active timers\n      if (keyPressTimerRef.current) {\n        clearInterval(keyPressTimerRef.current);\n      }\n      if (sequenceTimerRef.current) {\n        clearTimeout(sequenceTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Check sidebar state - run once on component mount and then on any DOM changes\n  useEffect(() => {\n    // Function to check if sidebar is open\n    const checkSidebar = () => {\n      const sidebar = document.querySelector('.sidebar');\n      if (sidebar) {\n        const isOpen = sidebar.classList.contains('open');\n        setIsSidebarOpen(isOpen);\n      }\n    };\n\n    // Initial check\n    checkSidebar();\n\n    // Set up a MutationObserver to watch for changes to the sidebar class\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          checkSidebar();\n        }\n      });\n    });\n\n    // Start observing the sidebar\n    const sidebar = document.querySelector('.sidebar');\n    if (sidebar) {\n      observer.observe(sidebar, { attributes: true });\n    }\n\n    // Clean up the observer on component unmount\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  // Determine horizontal direction based on x coordinate\n  const determineHorizontalDirection = (x) => {\n    if (x < 250) {\n      return \"left\";\n    } else if (x > 450) {\n      return \"right\";\n    } else {\n      return \"center\";\n    }\n  };\n\n  // Determine vertical direction based on y coordinate\n  const determineVerticalDirection = (y) => {\n    if (y < 200) {\n      return \"up\";\n    } else if (y > 350) {\n      return \"down\";\n    } else {\n      return \"center\";\n    }\n  };\n\n  // Simulate keyboard press for regular keys\n  const simulateKeyPress = (key) => {\n    try {\n      // Create keydown event\n      const keyDownEvent = new KeyboardEvent('keydown', {\n        key: key,\n        code: `Key${key.toUpperCase()}`,\n        keyCode: key.charCodeAt(0),\n        which: key.charCodeAt(0),\n        bubbles: true,\n        cancelable: true\n      });\n      \n      // Dispatch the event\n      document.dispatchEvent(keyDownEvent);\n      \n      // Log the key press\n      console.log(`Key ${key} pressed based on face direction`);\n      \n      // Create and dispatch keyup event after a short delay\n      setTimeout(() => {\n        const keyUpEvent = new KeyboardEvent('keyup', {\n          key: key,\n          code: `Key${key.toUpperCase()}`,\n          keyCode: key.charCodeAt(0),\n          which: key.charCodeAt(0),\n          bubbles: true,\n          cancelable: true\n        });\n        document.dispatchEvent(keyUpEvent);\n      }, 100);\n    } catch (error) {\n      console.error(\"Error simulating key press:\", error);\n    }\n  };\n\n  // Simulate arrow key press\n  const simulateArrowKeyPress = (direction) => {\n    try {\n      // Map direction to arrow key\n      const arrowKey = direction === 'left' ? 'ArrowLeft' : \n                       direction === 'right' ? 'ArrowRight' : \n                       direction === 'up' ? 'ArrowUp' : \n                       'ArrowDown';\n                       \n      // Create keydown event for arrow key\n      const keyDownEvent = new KeyboardEvent('keydown', {\n        key: arrowKey,\n        code: arrowKey,\n        keyCode: arrowKey === 'ArrowLeft' ? 37 : \n                 arrowKey === 'ArrowUp' ? 38 : \n                 arrowKey === 'ArrowRight' ? 39 : 40,\n        which: arrowKey === 'ArrowLeft' ? 37 : \n               arrowKey === 'ArrowUp' ? 38 : \n               arrowKey === 'ArrowRight' ? 39 : 40,\n        bubbles: true,\n        cancelable: true\n      });\n      \n      // Dispatch the event\n      document.dispatchEvent(keyDownEvent);\n      \n      // Log the key press\n      console.log(`Arrow key ${arrowKey} pressed based on face direction`);\n      \n      // Create and dispatch keyup event after a short delay\n      setTimeout(() => {\n        const keyUpEvent = new KeyboardEvent('keyup', {\n          key: arrowKey,\n          code: arrowKey,\n          keyCode: arrowKey === 'ArrowLeft' ? 37 : \n                   arrowKey === 'ArrowUp' ? 38 : \n                   arrowKey === 'ArrowRight' ? 39 : 40,\n          which: arrowKey === 'ArrowLeft' ? 37 : \n                 arrowKey === 'ArrowUp' ? 38 : \n                 arrowKey === 'ArrowRight' ? 39 : 40,\n          bubbles: true,\n          cancelable: true\n        });\n        document.dispatchEvent(keyUpEvent);\n      }, 100);\n    } catch (error) {\n      console.error(`Error simulating arrow key press for ${direction}:`, error);\n    }\n  };\n\n  // Get key for direction\n  const getKeyForDirection = (horizontalDir, verticalDir) => {\n    if (horizontalDir === \"left\") return 'l';\n    if (horizontalDir === \"right\") return 'r';\n    if (verticalDir === \"up\") return 'u';\n    if (verticalDir === \"down\") return 'd';\n    return null;\n  };\n\n  // Handle sequential key presses for multiple directions\n  const handleDirectionChanges = () => {\n    // Clear any existing timer\n    if (keyPressTimerRef.current) {\n      clearInterval(keyPressTimerRef.current);\n      keyPressTimerRef.current = null;\n    }\n    \n    if (sequenceTimerRef.current) {\n      clearTimeout(sequenceTimerRef.current);\n      sequenceTimerRef.current = null;\n    }\n    \n    // Check if we have any direction to handle\n    const horizontalDir = faceData.horizontalDirection;\n    const verticalDir = faceData.verticalDirection;\n    \n    // Store current directions to ref for next comparison\n    lastDirectionRef.current = {\n      horizontal: horizontalDir,\n      vertical: verticalDir\n    };\n    \n    // Determine if we need to handle multiple directions sequentially\n    const hasHorizontalMovement = horizontalDir !== \"center\";\n    const hasVerticalMovement = verticalDir !== \"center\";\n    \n    // First handle horizontal direction if it's not center\n    if (hasHorizontalMovement) {\n      const horizontalKey = horizontalDir === \"left\" ? 'l' : 'r';\n      \n      // Press both the letter key and the arrow key\n      simulateKeyPress(horizontalKey);\n      simulateArrowKeyPress(horizontalDir);\n      \n      // Set up interval for continuous horizontal key presses\n      keyPressTimerRef.current = setInterval(() => {\n        simulateKeyPress(horizontalKey);\n        simulateArrowKeyPress(horizontalDir);\n      }, 300);\n      \n      // If we also have vertical movement, handle it after horizontal\n      if (hasVerticalMovement) {\n        // After 1 second, switch to vertical direction\n        sequenceTimerRef.current = setTimeout(() => {\n          // Stop horizontal key presses\n          if (keyPressTimerRef.current) {\n            clearInterval(keyPressTimerRef.current);\n            keyPressTimerRef.current = null;\n          }\n          \n          // Start vertical key presses\n          const verticalKey = verticalDir === \"up\" ? 'u' : 'd';\n          simulateKeyPress(verticalKey);\n          simulateArrowKeyPress(verticalDir);\n          \n          keyPressTimerRef.current = setInterval(() => {\n            simulateKeyPress(verticalKey);\n            simulateArrowKeyPress(verticalDir);\n          }, 300);\n        }, 300); // 1 second delay before switching directions\n      }\n    }\n    // If only vertical direction is detected, handle it immediately\n    else if (hasVerticalMovement) {\n      const verticalKey = verticalDir === \"up\" ? 'u' : 'd';\n      \n      // Press both the letter key and the arrow key\n      simulateKeyPress(verticalKey);\n      simulateArrowKeyPress(verticalDir);\n      \n      // Set up interval for continuous vertical key presses\n      keyPressTimerRef.current = setInterval(() => {\n        simulateKeyPress(verticalKey);\n        simulateArrowKeyPress(verticalDir);\n      }, 300);\n    }\n    // If neither direction is active, do nothing (center position)\n  };\n\n  // Effect to handle direction changes and trigger key presses\n  useEffect(() => {\n    // Check if either direction has changed\n    if (faceData.horizontalDirection !== lastDirectionRef.current.horizontal || \n        faceData.verticalDirection !== lastDirectionRef.current.vertical) {\n      \n      handleDirectionChanges();\n    }\n  }, [faceData.horizontalDirection, faceData.verticalDirection]);\n\n  // Handle video load\n  const handleVideoLoad = async (videoNode) => {\n    const video = videoNode.target;\n    if (video.readyState !== 4) return;\n    if (loaded) return;\n\n    if (detector && webcamRef.current && canvasRef.current) {\n      await detector.start(\n        webcamRef.current.video, \n        canvasRef.current, \n        (data) => {\n          // Update face data when detection occurs\n          if (data && data.keypoints && data.keypoints[1]) {\n            const x = Math.round(data.keypoints[1].x);\n            const y = Math.round(data.keypoints[1].y);\n            const horizontalDirection = determineHorizontalDirection(x);\n            const verticalDirection = determineVerticalDirection(y);\n            \n            setFaceData({\n              position: { x, y },\n              direction: {\n                yaw: Math.round(data.yaw || 0),\n                turn: Math.round(data.turn || 0)\n              },\n              horizontalDirection,\n              verticalDirection\n            });\n          }\n        }\n      );\n      setLoaded(true);\n    }\n  };\n\n  // Helper function to get active key display text\n  const getActiveKeyText = () => {\n    const { horizontalDirection, verticalDirection } = faceData;\n    const hasHorizontal = horizontalDirection !== \"center\";\n    const hasVertical = verticalDirection !== \"center\";\n    \n    if (hasHorizontal && hasVertical) {\n      const hKey = horizontalDirection === \"left\" ? \"'l' + ←\" : \"'r' + →\";\n      const vKey = verticalDirection === \"up\" ? \"'u' + ↑\" : \"'d' + ↓\";\n      return ``;\n    } else if (hasHorizontal) {\n      const hKey = horizontalDirection === \"left\" ? \"'l' + ←\" : \"'r' + →\";\n      return ``;\n    } else if (hasVertical) {\n      const vKey = verticalDirection === \"up\" ? \"'u' + ↑\" : \"'d' + ↓\";\n      return `(pressing ${vKey})`;\n    } else {\n      return \"(no key press)\";\n    }\n  };\n\n  return (\n    <div>\n      {/* Hidden webcam and canvas for detection */}\n      <div style={{ position: \"absolute\", visibility: \"hidden\" }}>\n        <Webcam\n          ref={webcamRef}\n          width={inputResolution.width}\n          height={inputResolution.height}\n          videoConstraints={videoConstraints}\n          onLoadedData={handleVideoLoad}\n        />\n        \n        <canvas\n          ref={canvasRef}\n          width={inputResolution.width}\n          height={inputResolution.height}\n        />\n      </div>\n\n      {/* Simple display of face data - only show when sidebar is closed */}\n      {!isSidebarOpen && (\n        <div style={{ \n          position: \"fixed\", \n          bottom: \"20px\",\n          left: \"50%\",\n          transform: \"translateX(-50%)\",\n          backgroundColor: \"rgba(0, 0, 0, 0.7)\",\n          color: \"#00f2fe\",\n          padding: \"8px 16px\",\n          borderRadius: \"8px\",\n          fontFamily: \"monospace\",\n          fontSize: \"14px\",\n          zIndex: 1000,\n          display: \"flex\",\n          gap: \"16px\"\n        }}>\n          <div>\n            Position: x={faceData.position.x}, y={faceData.position.y}\n          </div>\n          <div>\n            Direction: H:{faceData.horizontalDirection.toUpperCase()} V:{faceData.verticalDirection.toUpperCase()} {getActiveKeyText()}\n          </div>\n          <div>\n            Angles: yaw={faceData.direction.yaw}°, turn={faceData.direction.turn}°\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default FaceDirectionComponent; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}