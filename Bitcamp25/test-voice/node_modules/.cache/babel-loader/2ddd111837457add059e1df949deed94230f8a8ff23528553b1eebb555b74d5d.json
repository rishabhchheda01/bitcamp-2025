{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { RetellWebClient } from \"retell-client-js-sdk\";\nimport SplineLoader from './SplineLoader';\nimport SplineViewer from './SplineViewer';\nimport './index.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  // Add a ref to maintain the Spline instance\n  const splineInstanceRef = useRef(null);\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [retellWebClient, setRetellWebClient] = useState(null);\n  const [eventStatus, setEventStatus] = useState({\n    callStarted: false,\n    callEnded: false,\n    agentStartTalking: false,\n    agentStopTalking: false,\n    error: null,\n    transcript: ''\n  });\n  const [micPermission, setMicPermission] = useState(null);\n  const [accessToken, setAccessToken] = useState('');\n  const [isGeneratingToken, setIsGeneratingToken] = useState(false);\n  const [callInfo, setCallInfo] = useState(null);\n  const [loadingComplete, setLoadingComplete] = useState(false);\n  const [showUI, setShowUI] = useState(true);\n  // Add state to control the mounting/unmounting of Spline\n  const [splineInitialized, setSplineInitialized] = useState(false);\n  // Add refs for animation control\n  const animationTimerRef = useRef(null);\n  const lastKeyPressRef = useRef(null);\n\n  // Agent ID for Retell\n  const AGENT_ID = \"agent_30b1b504a89d37e3109a7da3e9\";\n\n  // Server endpoint for token generation\n  const TOKEN_SERVER_URL = \"http://127.0.0.1:5000/api/generate-token\";\n\n  // Function to simulate a keyboard press\n  const simulateKeyPress = key => {\n    // Try to directly update through the iframe if it exists\n    if (splineInstanceRef.current) {\n      try {\n        const container = splineInstanceRef.current.getContainer();\n        if (container) {\n          // Try to find the iframe inside the spline viewer\n          const iframe = container.querySelector('iframe');\n          if (iframe) {\n            // Try to dispatch events to the iframe's content window\n            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            const keyDownEvent = new KeyboardEvent('keydown', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            const keyUpEvent = new KeyboardEvent('keyup', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            iframeDoc.dispatchEvent(keyDownEvent);\n            setTimeout(() => {\n              iframeDoc.dispatchEvent(keyUpEvent);\n            }, 100);\n            lastKeyPressRef.current = key;\n            return;\n          }\n        }\n      } catch (e) {\n        console.error(\"Error dispatching to iframe:\", e);\n      }\n    }\n\n    // Fallback to window\n    window.dispatchEvent(new KeyboardEvent('keydown', {\n      key: key,\n      code: `Key${key.toUpperCase()}`,\n      keyCode: key.charCodeAt(0),\n      bubbles: true\n    }));\n    setTimeout(() => {\n      window.dispatchEvent(new KeyboardEvent('keyup', {\n        key: key,\n        code: `Key${key.toUpperCase()}`,\n        keyCode: key.charCodeAt(0),\n        bubbles: true\n      }));\n    }, 100);\n    lastKeyPressRef.current = key;\n    console.log(`Simulated key press: ${key}`);\n  };\n\n  // Function to handle actual keyboard events (for testing purposes)\n  const handleKeyDown = e => {\n    console.log(`Actual key press: ${e.key}`);\n  };\n\n  // Add a hook to listen for real keyboard events for debugging\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n\n  // Function to start animation based on talking state\n  const startTalkingAnimation = () => {\n    // Clear any existing animation timer\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n    }\n\n    // Start with an initial key press\n    simulateKeyPress('u');\n\n    // Set up a new animation timer to simulate key presses while talking\n    animationTimerRef.current = setInterval(() => {\n      // Check if the transcript contains negation words\n      const hasNegation = eventStatus.transcript && (eventStatus.transcript.toLowerCase().includes('no') || eventStatus.transcript.toLowerCase().includes('not') || eventStatus.transcript.toLowerCase().includes(\"don't\") || eventStatus.transcript.toLowerCase().includes(\"doesn't\"));\n\n      // If there's negation, use left-right movements\n      if (hasNegation) {\n        // Alternate between left and right\n        if (lastKeyPressRef.current === 'l') {\n          simulateKeyPress('r');\n        } else {\n          simulateKeyPress('l');\n        }\n      } else {\n        // Otherwise use up-down movements\n        if (lastKeyPressRef.current === 'u') {\n          simulateKeyPress('d');\n        } else {\n          simulateKeyPress('u');\n        }\n      }\n    }, 500); // Animation interval of 0.5 seconds\n  };\n\n  // Function to stop animation\n  const stopTalkingAnimation = () => {\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n      animationTimerRef.current = null;\n    }\n  };\n\n  // Function to manually trigger animation for testing\n  const testAnimation = direction => {\n    simulateKeyPress(direction);\n  };\n  useEffect(() => {\n    // Initialize the RetellWebClient\n    const client = new RetellWebClient();\n    setRetellWebClient(client);\n\n    // Check for microphone permissions\n    checkMicrophonePermission();\n\n    // Set up event listeners\n    client.on(\"call_started\", () => {\n      console.log(\"call started\");\n      setEventStatus(prev => ({\n        ...prev,\n        callStarted: true,\n        callEnded: false\n      }));\n    });\n    client.on(\"call_ended\", () => {\n      console.log(\"call ended\");\n      setIsCallActive(false);\n      setEventStatus(prev => ({\n        ...prev,\n        callEnded: true\n      }));\n      stopTalkingAnimation();\n    });\n    client.on(\"agent_start_talking\", () => {\n      console.log(\"agent_start_talking\");\n      setEventStatus(prev => ({\n        ...prev,\n        agentStartTalking: true,\n        agentStopTalking: false\n      }));\n      startTalkingAnimation();\n    });\n    client.on(\"agent_stop_talking\", () => {\n      console.log(\"agent_stop_talking\");\n      setEventStatus(prev => ({\n        ...prev,\n        agentStopTalking: true,\n        agentStartTalking: false\n      }));\n      stopTalkingAnimation();\n    });\n    client.on(\"update\", update => {\n      console.log(\"Update received:\", update);\n      if (update.transcript) {\n        // Check if transcript is an object with role and content properties\n        if (typeof update.transcript === 'object' && update.transcript.role && update.transcript.content) {\n          // Extract the content text\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: update.transcript.content\n          }));\n        }\n        // Check if transcript is an array of message objects\n        else if (Array.isArray(update.transcript)) {\n          // Map through messages and format them\n          const formattedTranscript = update.transcript.map(msg => {\n            if (typeof msg === 'object' && msg.role && msg.content) {\n              return `${msg.role}: ${msg.content}`;\n            }\n            return String(msg); // Convert to string if it's some other type\n          }).join('\\n');\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: formattedTranscript\n          }));\n        }\n        // If it's a string or can be converted to string\n        else {\n          setEventStatus(prev => ({\n            ...prev,\n            transcript: String(update.transcript)\n          }));\n        }\n      }\n    });\n    client.on(\"metadata\", metadata => {\n      console.log(\"Metadata received:\", metadata);\n    });\n    client.on(\"error\", error => {\n      console.error(\"An error occurred:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Unknown error\"\n      }));\n      client.stopCall();\n      stopTalkingAnimation();\n    });\n\n    // Clean up event listeners and animation on component unmount\n    return () => {\n      stopTalkingAnimation();\n      if (client) {\n        client.stopCall();\n      }\n    };\n  }, []);\n\n  // Effect to handle animation when talking state changes\n  useEffect(() => {\n    if (eventStatus.agentStartTalking && !eventStatus.agentStopTalking) {\n      startTalkingAnimation();\n    } else {\n      stopTalkingAnimation();\n    }\n  }, [eventStatus.agentStartTalking, eventStatus.agentStopTalking]);\n\n  // Function to generate an access token from the server\n  const generateAccessToken = async () => {\n    try {\n      setIsGeneratingToken(true);\n      setEventStatus(prev => ({\n        ...prev,\n        error: null\n      }));\n      console.log(\"Requesting access token from server...\");\n\n      // Make the API call to our server endpoint\n      const response = await fetch(TOKEN_SERVER_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          agent_id: AGENT_ID\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `Server responded with status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.access_token) {\n        throw new Error(\"No access token received from server\");\n      }\n      console.log(\"Access token received from server:\", data.access_token);\n      setAccessToken(data.access_token);\n      setCallInfo(data); // Store the full call info for reference\n      setIsGeneratingToken(false);\n      return data.access_token;\n    } catch (error) {\n      console.error(\"Failed to generate access token:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Failed to generate access token\"\n      }));\n      setIsGeneratingToken(false);\n      return null;\n    }\n  };\n  const checkMicrophonePermission = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      setMicPermission('granted');\n      // Stop the stream tracks immediately\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      console.error('Microphone permission denied:', error);\n      setMicPermission('denied');\n    }\n  };\n  const requestMicrophonePermission = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      setMicPermission('granted');\n      return true;\n    } catch (error) {\n      console.error('Failed to get microphone permission:', error);\n      setMicPermission('denied');\n      return false;\n    }\n  };\n  const startCall = async () => {\n    if (!retellWebClient || isCallActive) return;\n\n    // First ensure we have microphone permissions\n    if (micPermission !== 'granted') {\n      const permissionGranted = await requestMicrophonePermission();\n      if (!permissionGranted) {\n        alert('Microphone permission is required to start a call');\n        return;\n      }\n    }\n    try {\n      // Reset event status\n      setEventStatus({\n        callStarted: false,\n        callEnded: false,\n        agentStartTalking: false,\n        agentStopTalking: false,\n        error: null,\n        transcript: ''\n      });\n\n      // Ensure we have a valid token\n      if (!accessToken) {\n        const token = await generateAccessToken();\n        if (!token) {\n          throw new Error(\"Failed to generate a valid access token\");\n        }\n      }\n      console.log(\"Starting call with access token...\");\n\n      // Start the call using the access token\n      await retellWebClient.startCall({\n        accessToken: accessToken,\n        sampleRate: 24000,\n        captureDeviceId: \"default\",\n        emitRawAudioSamples: false\n      });\n      setIsCallActive(true);\n    } catch (error) {\n      console.error(\"Failed to start call:\", error);\n      setEventStatus(prev => ({\n        ...prev,\n        error: error.message || \"Failed to start call\"\n      }));\n    }\n  };\n  const stopCall = () => {\n    if (retellWebClient && isCallActive) {\n      retellWebClient.stopCall();\n      setIsCallActive(false);\n    }\n  };\n\n  // Function to check if token is expired (tokens are valid for 30 seconds)\n  const isTokenExpired = () => {\n    // If we don't have token info, consider it expired\n    if (!accessToken || !callInfo) return true;\n\n    // Track when we received the token in our application\n    if (!callInfo._tokenReceivedTime) {\n      // If this is the first time checking, add a timestamp of when we received it\n      callInfo._tokenReceivedTime = Date.now();\n      setCallInfo({\n        ...callInfo\n      }); // Update the state to save this timestamp\n      return false; // Token is fresh\n    }\n\n    // Calculate how long ago we received the token\n    const tokenReceivedTime = callInfo._tokenReceivedTime;\n    const currentTime = Date.now();\n    const tokenAgeInSeconds = (currentTime - tokenReceivedTime) / 1000;\n\n    // Token expires after 30 seconds, but we consider it expired at 25s\n    // to give us a buffer to generate a new one\n    return tokenAgeInSeconds > 25;\n  };\n\n  // New function to handle loading completion and initialize Spline only once\n  const handleLoadingComplete = () => {\n    setLoadingComplete(true);\n    setSplineInitialized(true);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: !loadingComplete ? /*#__PURE__*/_jsxDEV(SplineLoader, {\n      onLoadingComplete: handleLoadingComplete\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 412,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"spline-container\",\n        children: splineInitialized && /*#__PURE__*/_jsxDEV(SplineViewer, {\n          ref: splineInstanceRef,\n          url: \"https://prod.spline.design/8CIsvX5hg8u-JUKM/scene.splinecode\",\n          options: {\n            hint: true,\n            'loading-anim-type': 'spinner-small-dark'\n          },\n          persistOnUpdate: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 419,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 416,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: `sidebar ${showUI ? 'open' : 'closed'}`,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"toggle-ui\",\n          onClick: () => setShowUI(!showUI),\n          children: showUI ? '×' : '≡'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 433,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"sidebar-content\",\n          children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"AI Voice\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 438,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"status-indicator\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: `status-dot ${isCallActive ? 'active' : 'inactive'}`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 441,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              children: isCallActive ? 'Connected' : 'Disconnected'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 442,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 440,\n            columnNumber: 15\n          }, this), micPermission !== 'granted' && /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: requestMicrophonePermission,\n            className: \"btn-secondary btn-small\",\n            children: \"Enable Mic\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 446,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"control-buttons\",\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: !accessToken || isTokenExpired() ? generateAccessToken : startCall,\n              disabled: isCallActive || isGeneratingToken,\n              className: \"btn-primary\",\n              children: !accessToken || isTokenExpired() ? \"Connect\" : isGeneratingToken ? \"...\" : \"Start\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 455,\n              columnNumber: 17\n            }, this), isCallActive && /*#__PURE__*/_jsxDEV(\"button\", {\n              onClick: stopCall,\n              className: \"btn-danger\",\n              children: \"End\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 468,\n              columnNumber: 19\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 454,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"animation-test\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"test-label\",\n              children: \"Test Animation:\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 479,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"test-buttons\",\n              children: [/*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"test-btn\",\n                onClick: () => testAnimation('u'),\n                children: \"Up\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 481,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"test-btn\",\n                onClick: () => testAnimation('d'),\n                children: \"Down\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 482,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"test-btn\",\n                onClick: () => testAnimation('l'),\n                children: \"Left\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 483,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n                className: \"test-btn\",\n                onClick: () => testAnimation('r'),\n                children: \"Right\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 484,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 480,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 478,\n            columnNumber: 15\n          }, this), eventStatus.error && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"error-badge\",\n            children: [\"Error: \", eventStatus.error]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 489,\n            columnNumber: 17\n          }, this), isCallActive && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"talking-indicator\",\n            children: eventStatus.agentStartTalking && !eventStatus.agentStopTalking ? /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"wave-animation\",\n              children: [/*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 499,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 500,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 501,\n                columnNumber: 23\n              }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"wave\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 502,\n                columnNumber: 23\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 498,\n              columnNumber: 21\n            }, this) : null\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 496,\n            columnNumber: 17\n          }, this), eventStatus.transcript && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"mini-transcript\",\n            children: /*#__PURE__*/_jsxDEV(\"p\", {\n              style: {\n                whiteSpace: 'pre-line'\n              },\n              children: eventStatus.transcript\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 511,\n              columnNumber: 19\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 510,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 437,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 432,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 410,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"cP6mviNJHNWocscGaYqqflRQ2hg=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","RetellWebClient","SplineLoader","SplineViewer","jsxDEV","_jsxDEV","Fragment","_Fragment","App","_s","splineInstanceRef","isCallActive","setIsCallActive","retellWebClient","setRetellWebClient","eventStatus","setEventStatus","callStarted","callEnded","agentStartTalking","agentStopTalking","error","transcript","micPermission","setMicPermission","accessToken","setAccessToken","isGeneratingToken","setIsGeneratingToken","callInfo","setCallInfo","loadingComplete","setLoadingComplete","showUI","setShowUI","splineInitialized","setSplineInitialized","animationTimerRef","lastKeyPressRef","AGENT_ID","TOKEN_SERVER_URL","simulateKeyPress","key","current","container","getContainer","iframe","querySelector","iframeDoc","contentDocument","contentWindow","document","keyDownEvent","KeyboardEvent","code","toUpperCase","keyCode","charCodeAt","bubbles","cancelable","keyUpEvent","dispatchEvent","setTimeout","e","console","window","log","handleKeyDown","addEventListener","removeEventListener","startTalkingAnimation","clearInterval","setInterval","hasNegation","toLowerCase","includes","stopTalkingAnimation","testAnimation","direction","client","checkMicrophonePermission","on","prev","update","role","content","Array","isArray","formattedTranscript","map","msg","String","join","metadata","message","stopCall","generateAccessToken","response","fetch","method","headers","body","JSON","stringify","agent_id","ok","errorData","json","Error","status","data","access_token","stream","navigator","mediaDevices","getUserMedia","audio","getTracks","forEach","track","stop","requestMicrophonePermission","startCall","permissionGranted","alert","token","sampleRate","captureDeviceId","emitRawAudioSamples","isTokenExpired","_tokenReceivedTime","Date","now","tokenReceivedTime","currentTime","tokenAgeInSeconds","handleLoadingComplete","className","children","onLoadingComplete","fileName","_jsxFileName","lineNumber","columnNumber","ref","url","options","hint","persistOnUpdate","onClick","disabled","style","whiteSpace","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { RetellWebClient } from \"retell-client-js-sdk\";\nimport SplineLoader from './SplineLoader';\nimport SplineViewer from './SplineViewer';\nimport './index.css';\n\nfunction App() {\n  // Add a ref to maintain the Spline instance\n  const splineInstanceRef = useRef(null);\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [retellWebClient, setRetellWebClient] = useState(null);\n  const [eventStatus, setEventStatus] = useState({\n    callStarted: false,\n    callEnded: false,\n    agentStartTalking: false,\n    agentStopTalking: false,\n    error: null,\n    transcript: ''\n  });\n  const [micPermission, setMicPermission] = useState(null);\n  const [accessToken, setAccessToken] = useState('');\n  const [isGeneratingToken, setIsGeneratingToken] = useState(false);\n  const [callInfo, setCallInfo] = useState(null);\n  const [loadingComplete, setLoadingComplete] = useState(false);\n  const [showUI, setShowUI] = useState(true);\n  // Add state to control the mounting/unmounting of Spline\n  const [splineInitialized, setSplineInitialized] = useState(false);\n  // Add refs for animation control\n  const animationTimerRef = useRef(null);\n  const lastKeyPressRef = useRef(null);\n\n  // Agent ID for Retell\n  const AGENT_ID = \"agent_30b1b504a89d37e3109a7da3e9\";\n  \n  // Server endpoint for token generation\n  const TOKEN_SERVER_URL = \"http://127.0.0.1:5000/api/generate-token\";\n\n  // Function to simulate a keyboard press\n  const simulateKeyPress = (key) => {\n    // Try to directly update through the iframe if it exists\n    if (splineInstanceRef.current) {\n      try {\n        const container = splineInstanceRef.current.getContainer();\n        if (container) {\n          // Try to find the iframe inside the spline viewer\n          const iframe = container.querySelector('iframe');\n          if (iframe) {\n            // Try to dispatch events to the iframe's content window\n            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            \n            const keyDownEvent = new KeyboardEvent('keydown', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            \n            const keyUpEvent = new KeyboardEvent('keyup', {\n              key: key,\n              code: `Key${key.toUpperCase()}`,\n              keyCode: key.charCodeAt(0),\n              bubbles: true,\n              cancelable: true\n            });\n            \n            iframeDoc.dispatchEvent(keyDownEvent);\n            \n            setTimeout(() => {\n              iframeDoc.dispatchEvent(keyUpEvent);\n            }, 100);\n            \n            lastKeyPressRef.current = key;\n            return;\n          }\n        }\n      } catch (e) {\n        console.error(\"Error dispatching to iframe:\", e);\n      }\n    }\n    \n    // Fallback to window\n    window.dispatchEvent(new KeyboardEvent('keydown', {\n      key: key,\n      code: `Key${key.toUpperCase()}`,\n      keyCode: key.charCodeAt(0),\n      bubbles: true\n    }));\n    \n    setTimeout(() => {\n      window.dispatchEvent(new KeyboardEvent('keyup', {\n        key: key,\n        code: `Key${key.toUpperCase()}`,\n        keyCode: key.charCodeAt(0),\n        bubbles: true\n      }));\n    }, 100);\n    \n    lastKeyPressRef.current = key;\n    console.log(`Simulated key press: ${key}`);\n  };\n\n  // Function to handle actual keyboard events (for testing purposes)\n  const handleKeyDown = (e) => {\n    console.log(`Actual key press: ${e.key}`);\n  };\n\n  // Add a hook to listen for real keyboard events for debugging\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n\n  // Function to start animation based on talking state\n  const startTalkingAnimation = () => {\n    // Clear any existing animation timer\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n    }\n    \n    // Start with an initial key press\n    simulateKeyPress('u');\n    \n    // Set up a new animation timer to simulate key presses while talking\n    animationTimerRef.current = setInterval(() => {\n      // Check if the transcript contains negation words\n      const hasNegation = eventStatus.transcript && (\n        eventStatus.transcript.toLowerCase().includes('no') || \n        eventStatus.transcript.toLowerCase().includes('not') ||\n        eventStatus.transcript.toLowerCase().includes(\"don't\") ||\n        eventStatus.transcript.toLowerCase().includes(\"doesn't\")\n      );\n      \n      // If there's negation, use left-right movements\n      if (hasNegation) {\n        // Alternate between left and right\n        if (lastKeyPressRef.current === 'l') {\n          simulateKeyPress('r');\n        } else {\n          simulateKeyPress('l');\n        }\n      } else {\n        // Otherwise use up-down movements\n        if (lastKeyPressRef.current === 'u') {\n          simulateKeyPress('d');\n        } else {\n          simulateKeyPress('u');\n        }\n      }\n    }, 500); // Animation interval of 0.5 seconds\n  };\n  \n  // Function to stop animation\n  const stopTalkingAnimation = () => {\n    if (animationTimerRef.current) {\n      clearInterval(animationTimerRef.current);\n      animationTimerRef.current = null;\n    }\n  };\n\n  // Function to manually trigger animation for testing\n  const testAnimation = (direction) => {\n    simulateKeyPress(direction);\n  };\n\n  useEffect(() => {\n    // Initialize the RetellWebClient\n    const client = new RetellWebClient();\n    setRetellWebClient(client);\n    \n    // Check for microphone permissions\n    checkMicrophonePermission();\n    \n    // Set up event listeners\n    client.on(\"call_started\", () => {\n      console.log(\"call started\");\n      setEventStatus(prev => ({ ...prev, callStarted: true, callEnded: false }));\n    });\n\n    client.on(\"call_ended\", () => {\n      console.log(\"call ended\");\n      setIsCallActive(false);\n      setEventStatus(prev => ({ ...prev, callEnded: true }));\n      stopTalkingAnimation();\n    });\n\n    client.on(\"agent_start_talking\", () => {\n      console.log(\"agent_start_talking\");\n      setEventStatus(prev => ({ ...prev, agentStartTalking: true, agentStopTalking: false }));\n      startTalkingAnimation();\n    });\n\n    client.on(\"agent_stop_talking\", () => {\n      console.log(\"agent_stop_talking\");\n      setEventStatus(prev => ({ ...prev, agentStopTalking: true, agentStartTalking: false }));\n      stopTalkingAnimation();\n    });\n\n    client.on(\"update\", (update) => {\n      console.log(\"Update received:\", update);\n      if (update.transcript) {\n        // Check if transcript is an object with role and content properties\n        if (typeof update.transcript === 'object' && update.transcript.role && update.transcript.content) {\n          // Extract the content text\n          setEventStatus(prev => ({ ...prev, transcript: update.transcript.content }));\n        } \n        // Check if transcript is an array of message objects\n        else if (Array.isArray(update.transcript)) {\n          // Map through messages and format them\n          const formattedTranscript = update.transcript\n            .map(msg => {\n              if (typeof msg === 'object' && msg.role && msg.content) {\n                return `${msg.role}: ${msg.content}`;\n              }\n              return String(msg); // Convert to string if it's some other type\n            })\n            .join('\\n');\n          setEventStatus(prev => ({ ...prev, transcript: formattedTranscript }));\n        } \n        // If it's a string or can be converted to string\n        else {\n          setEventStatus(prev => ({ ...prev, transcript: String(update.transcript) }));\n        }\n      }\n    });\n\n    client.on(\"metadata\", (metadata) => {\n      console.log(\"Metadata received:\", metadata);\n    });\n\n    client.on(\"error\", (error) => {\n      console.error(\"An error occurred:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Unknown error\" }));\n      client.stopCall();\n      stopTalkingAnimation();\n    });\n    \n    // Clean up event listeners and animation on component unmount\n    return () => {\n      stopTalkingAnimation();\n      if (client) {\n        client.stopCall();\n      }\n    };\n  }, []);\n\n  // Effect to handle animation when talking state changes\n  useEffect(() => {\n    if (eventStatus.agentStartTalking && !eventStatus.agentStopTalking) {\n      startTalkingAnimation();\n    } else {\n      stopTalkingAnimation();\n    }\n  }, [eventStatus.agentStartTalking, eventStatus.agentStopTalking]);\n  \n  // Function to generate an access token from the server\n  const generateAccessToken = async () => {\n    try {\n      setIsGeneratingToken(true);\n      setEventStatus(prev => ({ ...prev, error: null }));\n      console.log(\"Requesting access token from server...\");\n      \n      // Make the API call to our server endpoint\n      const response = await fetch(TOKEN_SERVER_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          agent_id: AGENT_ID,\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `Server responded with status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      if (!data.access_token) {\n        throw new Error(\"No access token received from server\");\n      }\n      \n      console.log(\"Access token received from server:\", data.access_token);\n      setAccessToken(data.access_token);\n      setCallInfo(data); // Store the full call info for reference\n      setIsGeneratingToken(false);\n      \n      return data.access_token;\n    } catch (error) {\n      console.error(\"Failed to generate access token:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Failed to generate access token\" }));\n      setIsGeneratingToken(false);\n      return null;\n    }\n  };\n  \n  const checkMicrophonePermission = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      setMicPermission('granted');\n      // Stop the stream tracks immediately\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      console.error('Microphone permission denied:', error);\n      setMicPermission('denied');\n    }\n  };\n  \n  const requestMicrophonePermission = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({ audio: true });\n      setMicPermission('granted');\n      return true;\n    } catch (error) {\n      console.error('Failed to get microphone permission:', error);\n      setMicPermission('denied');\n      return false;\n    }\n  };\n  \n  const startCall = async () => {\n    if (!retellWebClient || isCallActive) return;\n    \n    // First ensure we have microphone permissions\n    if (micPermission !== 'granted') {\n      const permissionGranted = await requestMicrophonePermission();\n      if (!permissionGranted) {\n        alert('Microphone permission is required to start a call');\n        return;\n      }\n    }\n    \n    try {\n      // Reset event status\n      setEventStatus({\n        callStarted: false,\n        callEnded: false,\n        agentStartTalking: false,\n        agentStopTalking: false,\n        error: null,\n        transcript: ''\n      });\n      \n      // Ensure we have a valid token\n      if (!accessToken) {\n        const token = await generateAccessToken();\n        if (!token) {\n          throw new Error(\"Failed to generate a valid access token\");\n        }\n      }\n      \n      console.log(\"Starting call with access token...\");\n      \n      // Start the call using the access token\n      await retellWebClient.startCall({\n        accessToken: accessToken,\n        sampleRate: 24000,\n        captureDeviceId: \"default\",\n        emitRawAudioSamples: false,\n      });\n      \n      setIsCallActive(true);\n    } catch (error) {\n      console.error(\"Failed to start call:\", error);\n      setEventStatus(prev => ({ ...prev, error: error.message || \"Failed to start call\" }));\n    }\n  };\n  \n  const stopCall = () => {\n    if (retellWebClient && isCallActive) {\n      retellWebClient.stopCall();\n      setIsCallActive(false);\n    }\n  };\n  \n  // Function to check if token is expired (tokens are valid for 30 seconds)\n  const isTokenExpired = () => {\n    // If we don't have token info, consider it expired\n    if (!accessToken || !callInfo) return true;\n    \n    // Track when we received the token in our application\n    if (!callInfo._tokenReceivedTime) {\n      // If this is the first time checking, add a timestamp of when we received it\n      callInfo._tokenReceivedTime = Date.now();\n      setCallInfo({...callInfo}); // Update the state to save this timestamp\n      return false; // Token is fresh\n    }\n    \n    // Calculate how long ago we received the token\n    const tokenReceivedTime = callInfo._tokenReceivedTime;\n    const currentTime = Date.now();\n    const tokenAgeInSeconds = (currentTime - tokenReceivedTime) / 1000;\n    \n    // Token expires after 30 seconds, but we consider it expired at 25s\n    // to give us a buffer to generate a new one\n    return tokenAgeInSeconds > 25;\n  };\n  \n  // New function to handle loading completion and initialize Spline only once\n  const handleLoadingComplete = () => {\n    setLoadingComplete(true);\n    setSplineInitialized(true);\n  };\n\n  return (\n    <div className=\"App\">\n      {!loadingComplete ? (\n        <SplineLoader onLoadingComplete={handleLoadingComplete} />\n      ) : (\n        <>\n          {/* Main Spline Animation filling the entire viewport */}\n          <div className=\"spline-container\">\n            {/* Use splineInitialized to ensure it's only mounted once */}\n            {splineInitialized && (\n              <SplineViewer \n                ref={splineInstanceRef}\n                url=\"https://prod.spline.design/8CIsvX5hg8u-JUKM/scene.splinecode\"\n                options={{\n                  hint: true,\n                  'loading-anim-type': 'spinner-small-dark'\n                }}\n                persistOnUpdate={true}\n              />\n            )}\n          </div>\n          \n          {/* Minimal UI sidebar */}\n          <div className={`sidebar ${showUI ? 'open' : 'closed'}`}>\n            <div className=\"toggle-ui\" onClick={() => setShowUI(!showUI)}>\n              {showUI ? '×' : '≡'}\n            </div>\n            \n            <div className=\"sidebar-content\">\n              <h2>AI Voice</h2>\n              \n              <div className=\"status-indicator\">\n                <div className={`status-dot ${isCallActive ? 'active' : 'inactive'}`}></div>\n                <span>{isCallActive ? 'Connected' : 'Disconnected'}</span>\n              </div>\n              \n              {micPermission !== 'granted' && (\n                <button \n                  onClick={requestMicrophonePermission}\n                  className=\"btn-secondary btn-small\"\n                >\n                  Enable Mic\n                </button>\n              )}\n              \n              <div className=\"control-buttons\">\n                <button \n                  onClick={!accessToken || isTokenExpired() ? generateAccessToken : startCall} \n                  disabled={isCallActive || isGeneratingToken}\n                  className=\"btn-primary\"\n                >\n                  {!accessToken || isTokenExpired() \n                    ? \"Connect\" \n                    : isGeneratingToken \n                      ? \"...\" \n                      : \"Start\"}\n                </button>\n                \n                {isCallActive && (\n                  <button \n                    onClick={stopCall} \n                    className=\"btn-danger\"\n                  >\n                    End\n                  </button>\n                )}\n              </div>\n              \n              {/* Animation test buttons */}\n              <div className=\"animation-test\">\n                <div className=\"test-label\">Test Animation:</div>\n                <div className=\"test-buttons\">\n                  <button className=\"test-btn\" onClick={() => testAnimation('u')}>Up</button>\n                  <button className=\"test-btn\" onClick={() => testAnimation('d')}>Down</button>\n                  <button className=\"test-btn\" onClick={() => testAnimation('l')}>Left</button>\n                  <button className=\"test-btn\" onClick={() => testAnimation('r')}>Right</button>\n                </div>\n              </div>\n              \n              {eventStatus.error && (\n                <div className=\"error-badge\">\n                  Error: {eventStatus.error}\n                </div>\n              )}\n              \n              {/* Minimalistic talking indicator */}\n              {isCallActive && (\n                <div className=\"talking-indicator\">\n                  {eventStatus.agentStartTalking && !eventStatus.agentStopTalking ? (\n                    <div className=\"wave-animation\">\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                      <div className=\"wave\"></div>\n                    </div>\n                  ) : null}\n                </div>\n              )}\n              \n              {/* Transcript in a minimal scrollable area */}\n              {eventStatus.transcript && (\n                <div className=\"mini-transcript\">\n                  <p style={{ whiteSpace: 'pre-line' }}>{eventStatus.transcript}</p>\n                </div>\n              )}\n            </div>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}