{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\n\n// This component uses the global moveSplineCursor function to control the Spline cursor\nconst SplineScript = ({\n  position\n}) => {\n  _s();\n  const lastUpdateRef = useRef(0);\n  const lastPositionRef = useRef({\n    x: 0,\n    y: 0\n  });\n  useEffect(() => {\n    // Throttle updates to avoid overwhelming the renderer\n    const now = Date.now();\n\n    // Only update if position changed or enough time has passed\n    if (now - lastUpdateRef.current > 16 ||\n    // ~60fps\n    Math.abs(position.x - lastPositionRef.current.x) > 1 || Math.abs(position.y - lastPositionRef.current.y) > 1) {\n      // Try multiple methods to control the Spline cursor\n\n      // Method 1: Use the global moveSplineCursor function if it exists\n      if (typeof window.moveSplineCursor === 'function') {\n        window.moveSplineCursor(position.x, position.y);\n      }\n\n      // Method 2: Fall back to manually finding and controlling the Spline viewer\n      else {\n        const splineElement = document.querySelector('spline-viewer');\n        if (splineElement) {\n          // Try using pointer events first (more modern)\n          try {\n            const pointerEvent = new PointerEvent('pointermove', {\n              bubbles: true,\n              cancelable: true,\n              clientX: position.x,\n              clientY: position.y,\n              pointerId: 1,\n              pointerType: 'mouse'\n            });\n            splineElement.dispatchEvent(pointerEvent);\n          } catch (e) {\n            // If pointer event fails, try mouse event\n            try {\n              splineElement.dispatchEvent(new MouseEvent('mousemove', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                clientX: position.x,\n                clientY: position.y\n              }));\n            } catch (e) {\n              // Silent catch to avoid console spam\n            }\n          }\n\n          // Try to access Spline's internal cursor if available\n          try {\n            if (splineElement.app && splineElement.app.cursor) {\n              splineElement.app.cursor.position.x = position.x;\n              splineElement.app.cursor.position.y = position.y;\n            }\n          } catch (e) {\n            // Silent catch for internal access\n          }\n        }\n      }\n\n      // Update the refs\n      lastUpdateRef.current = now;\n      lastPositionRef.current = {\n        ...position\n      };\n    }\n  }, [position]);\n\n  // Add a script to help debug events on the Spline element\n  useEffect(() => {\n    // One-time setup to inject a debugging script\n    const script = document.createElement('script');\n    script.textContent = `\n      // Monitor events on the Spline element when it appears\n      (function() {\n        const checkForSpline = setInterval(() => {\n          const splineElement = document.querySelector('spline-viewer');\n          if (splineElement) {\n            clearInterval(checkForSpline);\n            console.log('Debug: Found Spline element, attaching event monitors');\n            \n            // Only log every 100th event to avoid spam\n            let eventCounter = 0;\n            \n            // Monitor mouse movement\n            splineElement.addEventListener('mousemove', (e) => {\n              eventCounter++;\n              if (eventCounter % 100 === 0) {\n                console.log('Debug: Spline received mousemove', e.clientX, e.clientY);\n              }\n            });\n            \n            // Monitor pointer movement\n            splineElement.addEventListener('pointermove', (e) => {\n              eventCounter++;\n              if (eventCounter % 100 === 0) {\n                console.log('Debug: Spline received pointermove', e.clientX, e.clientY);\n              }\n            });\n          }\n        }, 1000);\n      })();\n    `;\n    document.head.appendChild(script);\n    return () => {\n      document.head.removeChild(script);\n    };\n  }, []);\n  return null; // This component doesn't render anything visible\n};\n_s(SplineScript, \"bcupO2TmPCLNCbKz28hny2NDEls=\");\n_c = SplineScript;\nexport default SplineScript;\nvar _c;\n$RefreshReg$(_c, \"SplineScript\");","map":{"version":3,"names":["React","useEffect","useRef","SplineScript","position","_s","lastUpdateRef","lastPositionRef","x","y","now","Date","current","Math","abs","window","moveSplineCursor","splineElement","document","querySelector","pointerEvent","PointerEvent","bubbles","cancelable","clientX","clientY","pointerId","pointerType","dispatchEvent","e","MouseEvent","view","app","cursor","script","createElement","textContent","head","appendChild","removeChild","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/SplineScript.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\n\r\n// This component uses the global moveSplineCursor function to control the Spline cursor\r\nconst SplineScript = ({ position }) => {\r\n  const lastUpdateRef = useRef(0);\r\n  const lastPositionRef = useRef({ x: 0, y: 0 });\r\n  \r\n  useEffect(() => {\r\n    // Throttle updates to avoid overwhelming the renderer\r\n    const now = Date.now();\r\n    \r\n    // Only update if position changed or enough time has passed\r\n    if ((now - lastUpdateRef.current > 16) || // ~60fps\r\n        (Math.abs(position.x - lastPositionRef.current.x) > 1) || \r\n        (Math.abs(position.y - lastPositionRef.current.y) > 1)) {\r\n      \r\n      // Try multiple methods to control the Spline cursor\r\n      \r\n      // Method 1: Use the global moveSplineCursor function if it exists\r\n      if (typeof window.moveSplineCursor === 'function') {\r\n        window.moveSplineCursor(position.x, position.y);\r\n      } \r\n      \r\n      // Method 2: Fall back to manually finding and controlling the Spline viewer\r\n      else {\r\n        const splineElement = document.querySelector('spline-viewer');\r\n        if (splineElement) {\r\n          // Try using pointer events first (more modern)\r\n          try {\r\n            const pointerEvent = new PointerEvent('pointermove', {\r\n              bubbles: true, \r\n              cancelable: true,\r\n              clientX: position.x,\r\n              clientY: position.y,\r\n              pointerId: 1,\r\n              pointerType: 'mouse'\r\n            });\r\n            splineElement.dispatchEvent(pointerEvent);\r\n          } catch (e) {\r\n            // If pointer event fails, try mouse event\r\n            try {\r\n              splineElement.dispatchEvent(new MouseEvent('mousemove', {\r\n                bubbles: true, \r\n                cancelable: true,\r\n                view: window,\r\n                clientX: position.x,\r\n                clientY: position.y\r\n              }));\r\n            } catch (e) {\r\n              // Silent catch to avoid console spam\r\n            }\r\n          }\r\n          \r\n          // Try to access Spline's internal cursor if available\r\n          try {\r\n            if (splineElement.app && splineElement.app.cursor) {\r\n              splineElement.app.cursor.position.x = position.x;\r\n              splineElement.app.cursor.position.y = position.y;\r\n            }\r\n          } catch (e) {\r\n            // Silent catch for internal access\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Update the refs\r\n      lastUpdateRef.current = now;\r\n      lastPositionRef.current = { ...position };\r\n    }\r\n  }, [position]);\r\n  \r\n  // Add a script to help debug events on the Spline element\r\n  useEffect(() => {\r\n    // One-time setup to inject a debugging script\r\n    const script = document.createElement('script');\r\n    script.textContent = `\r\n      // Monitor events on the Spline element when it appears\r\n      (function() {\r\n        const checkForSpline = setInterval(() => {\r\n          const splineElement = document.querySelector('spline-viewer');\r\n          if (splineElement) {\r\n            clearInterval(checkForSpline);\r\n            console.log('Debug: Found Spline element, attaching event monitors');\r\n            \r\n            // Only log every 100th event to avoid spam\r\n            let eventCounter = 0;\r\n            \r\n            // Monitor mouse movement\r\n            splineElement.addEventListener('mousemove', (e) => {\r\n              eventCounter++;\r\n              if (eventCounter % 100 === 0) {\r\n                console.log('Debug: Spline received mousemove', e.clientX, e.clientY);\r\n              }\r\n            });\r\n            \r\n            // Monitor pointer movement\r\n            splineElement.addEventListener('pointermove', (e) => {\r\n              eventCounter++;\r\n              if (eventCounter % 100 === 0) {\r\n                console.log('Debug: Spline received pointermove', e.clientX, e.clientY);\r\n              }\r\n            });\r\n          }\r\n        }, 1000);\r\n      })();\r\n    `;\r\n    document.head.appendChild(script);\r\n    \r\n    return () => {\r\n      document.head.removeChild(script);\r\n    };\r\n  }, []);\r\n  \r\n  return null; // This component doesn't render anything visible\r\n};\r\n\r\nexport default SplineScript; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}