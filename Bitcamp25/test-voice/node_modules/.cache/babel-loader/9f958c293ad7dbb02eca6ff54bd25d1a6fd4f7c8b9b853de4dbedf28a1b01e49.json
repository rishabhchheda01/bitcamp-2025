{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, GatherV2, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { CppDType } from './types';\nlet wasmGather;\nfunction setup(backend) {\n  wasmGather = backend.wasm.cwrap('Gather', null /*void*/, ['number', 'number', 'array', 'number', 'number', 'number', 'array', 'number' // outId\n  ]);\n}\nfunction gatherV2(args) {\n  const {\n    backend,\n    inputs,\n    attrs\n  } = args;\n  const {\n    x,\n    indices\n  } = inputs;\n  const {\n    axis,\n    batchDims\n  } = attrs;\n  // Throw error when any index is out of bound.\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const indicesVals = backend.readSync(indices.dataId);\n  const axisDim = x.shape[parsedAxis];\n  for (let i = 0; i < indicesVals.length; ++i) {\n    const index = indicesVals[i];\n    util.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);\n  }\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);\n  const flattenX = reshape({\n    inputs: {\n      x\n    },\n    attrs: {\n      shape: [shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize, shapeInfo.sliceSize]\n    },\n    backend\n  });\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const flattenIndex = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]\n    },\n    backend\n  });\n  const flattenOutputShape = [shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize, shapeInfo.sliceSize];\n  const out = backend.makeOutput(flattenOutputShape, x.dtype);\n  if (util.sizeFromShape(x.shape) === 0) {\n    return out;\n  }\n  const stridesSize = flattenX.shape.length - 1;\n  const xData = backend.dataIdMap.get(flattenX.dataId);\n  const xId = xData.id;\n  const indicesData = backend.dataIdMap.get(flattenIndex.dataId);\n  const indicesId = indicesData.id;\n  const outId = backend.dataIdMap.get(out.dataId).id;\n  const xStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(flattenX.shape)).buffer);\n  const outStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(flattenOutputShape)).buffer);\n  wasmGather(xId, CppDType[x.dtype], xStridesBytes, stridesSize, indicesId, shapeInfo.batchSize, outStridesBytes, outId);\n  backend.disposeData(flattenX.dataId);\n  backend.disposeData(flattenIndex.dataId);\n  // reshape\n  out.shape = shapeInfo.outputShape;\n  return out;\n}\nexport const gatherV2Config = {\n  kernelName: GatherV2,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: gatherV2\n};","map":{"version":3,"names":["backend_util","GatherV2","util","reshape","CppDType","wasmGather","setup","backend","wasm","cwrap","gatherV2","args","inputs","attrs","x","indices","axis","batchDims","parsedAxis","parseAxisParam","shape","indicesVals","readSync","dataId","axisDim","i","length","index","assert","shapeInfo","segment_util","collectGatherOpShapeInfo","flattenX","batchSize","outerSize","dimSize","sliceSize","indicesSize","sizeFromShape","flattenIndex","flattenOutputShape","out","makeOutput","dtype","stridesSize","xData","dataIdMap","get","xId","id","indicesData","indicesId","outId","xStridesBytes","Uint8Array","Int32Array","computeStrides","buffer","outStridesBytes","disposeData","outputShape","gatherV2Config","kernelName","backendName","setupFunc","kernelFunc"],"sources":["C:\\Users\\kheri\\Downloads\\Bitcamp\\bitcamp-2025\\Bitcamp25\\tfjs-backend-wasm\\src\\kernels\\GatherV2.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherV2, GatherV2Attrs, GatherV2Inputs, KernelConfig, KernelFunc, Tensor, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\n\nimport {reshape} from './Reshape';\nimport {CppDType} from './types';\n\nlet wasmGather: (\n    xId: number, dtype: CppDType, xStrides: Uint8Array, stridesSize: number,\n    indicesId: number, batchSize: number, outStrides: Uint8Array,\n    outId: number) => void;\n\nfunction setup(backend: BackendWasm): void {\n  wasmGather = backend.wasm.cwrap('Gather', null /*void*/, [\n    'number',  // xId\n    'number',  // dtype\n    'array',   // xStrides\n    'number',  // stridesSize\n    'number',  // indicesId\n    'number',  // batchSize\n    'array',   // outStrides\n    'number'   // outId\n  ]);\n}\n\nfunction gatherV2(\n    args: {backend: BackendWasm, inputs: GatherV2Inputs, attrs: GatherV2Attrs}):\n    TensorInfo {\n  const {backend, inputs, attrs} = args;\n  const {x, indices} = inputs;\n  const {axis, batchDims} = attrs;\n\n  // Throw error when any index is out of bound.\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const indicesVals = backend.readSync(indices.dataId) as TypedArray;\n  const axisDim = x.shape[parsedAxis];\n  for (let i = 0; i < indicesVals.length; ++i) {\n    const index = indicesVals[i];\n    util.assert(\n        index <= axisDim - 1 && index >= 0,\n        () =>\n            `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);\n  }\n\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(\n      x as Tensor, indices as Tensor, parsedAxis, batchDims);\n\n  const flattenX = reshape({\n    inputs: {x},\n    attrs: {\n      shape: [\n        shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n        shapeInfo.sliceSize\n      ]\n    },\n    backend\n  });\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const flattenIndex = reshape({\n    inputs: {x: indices},\n    attrs: {shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]},\n    backend\n  });\n  const flattenOutputShape = [\n    shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n    shapeInfo.sliceSize\n  ];\n\n  const out = backend.makeOutput(flattenOutputShape, x.dtype);\n  if (util.sizeFromShape(x.shape) === 0) {\n    return out;\n  }\n  const stridesSize = flattenX.shape.length - 1;\n\n  const xData = backend.dataIdMap.get(flattenX.dataId);\n  const xId = xData.id;\n\n  const indicesData = backend.dataIdMap.get(flattenIndex.dataId);\n  const indicesId = indicesData.id;\n\n  const outId = backend.dataIdMap.get(out.dataId).id;\n\n  const xStridesBytes = new Uint8Array(\n      new Int32Array(util.computeStrides(flattenX.shape)).buffer);\n  const outStridesBytes = new Uint8Array(\n      new Int32Array(util.computeStrides(flattenOutputShape)).buffer);\n\n  wasmGather(\n      xId, CppDType[x.dtype], xStridesBytes, stridesSize, indicesId,\n      shapeInfo.batchSize, outStridesBytes, outId);\n\n  backend.disposeData(flattenX.dataId);\n  backend.disposeData(flattenIndex.dataId);\n\n  // reshape\n  out.shape = shapeInfo.outputShape;\n  return out;\n}\n\nexport const gatherV2Config: KernelConfig = {\n  kernelName: GatherV2,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: gatherV2 as unknown as KernelFunc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}