{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kheri\\\\Downloads\\\\Bitcamp\\\\bitcamp-2025\\\\Bitcamp25\\\\test-voice\\\\src\\\\FaceDetector.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport Webcam from 'react-webcam';\nimport { useFaceDetection } from 'react-use-face-detection';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FaceDetector = ({\n  onFacePositionChange,\n  isEnabled = true\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const [error, setError] = useState(null);\n\n  // Initialize face detection with MediaPipe\n  const {\n    boundingBox,\n    webcamRef: faceDetectionWebcamRef,\n    isLoading,\n    detected,\n    facesDetected\n  } = useFaceDetection({\n    faceDetectionOptions: {\n      model: 'short'\n    }\n  });\n\n  // Set webcam reference from face detection hook to our ref\n  useEffect(() => {\n    try {\n      webcamRef.current = faceDetectionWebcamRef.current;\n    } catch (err) {\n      console.error('Error setting webcam ref:', err);\n      setError('Failed to initialize webcam');\n    }\n  }, [faceDetectionWebcamRef]);\n\n  // Process bounding box data to determine face position\n  useEffect(() => {\n    try {\n      if (!isEnabled || !detected || !boundingBox || boundingBox.length === 0) return;\n\n      // We'll use the first detected face\n      const face = boundingBox[0];\n\n      // Calculate the center of the face\n      const centerX = face.topLeft[0] + (face.bottomRight[0] - face.topLeft[0]) / 2;\n      const centerY = face.topLeft[1] + (face.bottomRight[1] - face.topLeft[1]) / 2;\n\n      // Calculate position relative to the webcam dimensions (as percentage)\n      const relativeX = centerX / 640; // Assuming 640 width\n      const relativeY = centerY / 480; // Assuming 480 height\n\n      // Determine which direction to move based on face position\n      // We divide the screen into sections for simplicity\n      let direction = null;\n\n      // Horizontal position (left/right)\n      if (relativeX < 0.4) {\n        direction = 'l'; // Move left when face is on the right side\n      } else if (relativeX > 0.6) {\n        direction = 'r'; // Move right when face is on the left side\n      }\n      // Vertical position (up/down) - only if horizontal is not active\n      else if (relativeY < 0.4) {\n        direction = 'u'; // Move up when face is low\n      } else if (relativeY > 0.6) {\n        direction = 'd'; // Move down when face is high\n      }\n\n      // Call the callback with the direction if set\n      if (direction && onFacePositionChange) {\n        onFacePositionChange(direction, {\n          x: relativeX,\n          y: relativeY\n        });\n      }\n    } catch (err) {\n      console.error('Error processing face position:', err);\n      setError('Failed to process face position');\n    }\n  }, [boundingBox, detected, isEnabled, onFacePositionChange]);\n\n  // Function to request camera permission\n  const requestCameraPermission = async () => {\n    try {\n      await navigator.mediaDevices.getUserMedia({\n        video: true\n      });\n      setError(null);\n    } catch (err) {\n      console.error('Camera permission denied:', err);\n      setError('Camera permission denied. Please enable camera access.');\n    }\n  };\n\n  // Handle errors in detection\n  useEffect(() => {\n    if (isEnabled && !isLoading && !detected && !error) {\n      // No faces detected after loading, but no error yet\n      const timer = setTimeout(() => {\n        if (!detected) {\n          requestCameraPermission();\n        }\n      }, 5000); // Check after 5 seconds of no detection\n\n      return () => clearTimeout(timer);\n    }\n  }, [isEnabled, isLoading, detected, error]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `face-detector ${isEnabled ? 'active' : 'inactive'}`,\n    children: isEnabled && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative'\n      },\n      children: [/*#__PURE__*/_jsxDEV(Webcam, {\n        ref: faceDetectionWebcamRef,\n        className: \"face-detection-webcam\",\n        mirrored: true,\n        screenshotFormat: \"image/jpeg\",\n        style: {\n          width: '100%',\n          height: 'auto',\n          maxWidth: '200px',\n          borderRadius: '8px',\n          opacity: 0.8\n        },\n        onUserMediaError: err => {\n          console.error('Webcam error:', err);\n          setError('Camera access error: ' + err.message);\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"detection-status\",\n        children: error ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator error\",\n          onClick: requestCameraPermission,\n          children: [error, \" (Click to retry)\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 118,\n          columnNumber: 15\n        }, this) : isLoading ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator loading\",\n          children: \"Loading model...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 122,\n          columnNumber: 15\n        }, this) : detected ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator detected\",\n          children: [facesDetected, \" face\", facesDetected !== 1 ? 's' : '', \" detected\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 124,\n          columnNumber: 15\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator not-detected\",\n          children: \"No faces detected\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 128,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 11\n      }, this), !error && boundingBox && boundingBox.length > 0 && /*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"bounding-box-visualization\",\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%'\n        },\n        children: boundingBox.map((box, index) => /*#__PURE__*/_jsxDEV(\"rect\", {\n          x: `${box.topLeft[0] / 640 * 100}%`,\n          y: `${box.topLeft[1] / 480 * 100}%`,\n          width: `${(box.bottomRight[0] - box.topLeft[0]) / 640 * 100}%`,\n          height: `${(box.bottomRight[1] - box.topLeft[1]) / 480 * 100}%`,\n          stroke: \"#00FFFF\",\n          strokeWidth: \"2\",\n          fill: \"none\"\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 133,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 95,\n    columnNumber: 5\n  }, this);\n};\n_s(FaceDetector, \"vdwebFLEEu7NPZ3p7Vxb3Ib5Q/4=\", false, function () {\n  return [useFaceDetection];\n});\n_c = FaceDetector;\nexport default FaceDetector;\nvar _c;\n$RefreshReg$(_c, \"FaceDetector\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Webcam","useFaceDetection","jsxDEV","_jsxDEV","FaceDetector","onFacePositionChange","isEnabled","_s","webcamRef","error","setError","boundingBox","faceDetectionWebcamRef","isLoading","detected","facesDetected","faceDetectionOptions","model","current","err","console","length","face","centerX","topLeft","bottomRight","centerY","relativeX","relativeY","direction","x","y","requestCameraPermission","navigator","mediaDevices","getUserMedia","video","timer","setTimeout","clearTimeout","className","children","style","position","ref","mirrored","screenshotFormat","width","height","maxWidth","borderRadius","opacity","onUserMediaError","message","fileName","_jsxFileName","lineNumber","columnNumber","onClick","top","left","map","box","index","stroke","strokeWidth","fill","_c","$RefreshReg$"],"sources":["C:/Users/kheri/Downloads/Bitcamp/bitcamp-2025/Bitcamp25/test-voice/src/FaceDetector.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport Webcam from 'react-webcam';\r\nimport { useFaceDetection } from 'react-use-face-detection';\r\n\r\nconst FaceDetector = ({ onFacePositionChange, isEnabled = true }) => {\r\n  const webcamRef = useRef(null);\r\n  const [error, setError] = useState(null);\r\n  \r\n  // Initialize face detection with MediaPipe\r\n  const { boundingBox, webcamRef: faceDetectionWebcamRef, isLoading, detected, facesDetected } = useFaceDetection({\r\n    faceDetectionOptions: {\r\n      model: 'short',\r\n    }\r\n  });\r\n\r\n  // Set webcam reference from face detection hook to our ref\r\n  useEffect(() => {\r\n    try {\r\n      webcamRef.current = faceDetectionWebcamRef.current;\r\n    } catch (err) {\r\n      console.error('Error setting webcam ref:', err);\r\n      setError('Failed to initialize webcam');\r\n    }\r\n  }, [faceDetectionWebcamRef]);\r\n\r\n  // Process bounding box data to determine face position\r\n  useEffect(() => {\r\n    try {\r\n      if (!isEnabled || !detected || !boundingBox || boundingBox.length === 0) return;\r\n\r\n      // We'll use the first detected face\r\n      const face = boundingBox[0];\r\n      \r\n      // Calculate the center of the face\r\n      const centerX = face.topLeft[0] + (face.bottomRight[0] - face.topLeft[0]) / 2;\r\n      const centerY = face.topLeft[1] + (face.bottomRight[1] - face.topLeft[1]) / 2;\r\n      \r\n      // Calculate position relative to the webcam dimensions (as percentage)\r\n      const relativeX = centerX / 640; // Assuming 640 width\r\n      const relativeY = centerY / 480; // Assuming 480 height\r\n      \r\n      // Determine which direction to move based on face position\r\n      // We divide the screen into sections for simplicity\r\n      let direction = null;\r\n      \r\n      // Horizontal position (left/right)\r\n      if (relativeX < 0.4) {\r\n        direction = 'l'; // Move left when face is on the right side\r\n      } else if (relativeX > 0.6) {\r\n        direction = 'r'; // Move right when face is on the left side\r\n      }\r\n      // Vertical position (up/down) - only if horizontal is not active\r\n      else if (relativeY < 0.4) {\r\n        direction = 'u'; // Move up when face is low\r\n      } else if (relativeY > 0.6) {\r\n        direction = 'd'; // Move down when face is high\r\n      }\r\n      \r\n      // Call the callback with the direction if set\r\n      if (direction && onFacePositionChange) {\r\n        onFacePositionChange(direction, { x: relativeX, y: relativeY });\r\n      }\r\n    } catch (err) {\r\n      console.error('Error processing face position:', err);\r\n      setError('Failed to process face position');\r\n    }\r\n  }, [boundingBox, detected, isEnabled, onFacePositionChange]);\r\n\r\n  // Function to request camera permission\r\n  const requestCameraPermission = async () => {\r\n    try {\r\n      await navigator.mediaDevices.getUserMedia({ video: true });\r\n      setError(null);\r\n    } catch (err) {\r\n      console.error('Camera permission denied:', err);\r\n      setError('Camera permission denied. Please enable camera access.');\r\n    }\r\n  };\r\n\r\n  // Handle errors in detection\r\n  useEffect(() => {\r\n    if (isEnabled && !isLoading && !detected && !error) {\r\n      // No faces detected after loading, but no error yet\r\n      const timer = setTimeout(() => {\r\n        if (!detected) {\r\n          requestCameraPermission();\r\n        }\r\n      }, 5000); // Check after 5 seconds of no detection\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isEnabled, isLoading, detected, error]);\r\n\r\n  return (\r\n    <div className={`face-detector ${isEnabled ? 'active' : 'inactive'}`}>\r\n      {isEnabled && (\r\n        <div style={{ position: 'relative' }}>\r\n          <Webcam\r\n            ref={faceDetectionWebcamRef}\r\n            className=\"face-detection-webcam\"\r\n            mirrored={true}\r\n            screenshotFormat=\"image/jpeg\"\r\n            style={{\r\n              width: '100%',\r\n              height: 'auto',\r\n              maxWidth: '200px',\r\n              borderRadius: '8px',\r\n              opacity: 0.8,\r\n            }}\r\n            onUserMediaError={(err) => {\r\n              console.error('Webcam error:', err);\r\n              setError('Camera access error: ' + err.message);\r\n            }}\r\n          />\r\n          {/* Face detection status indicator */}\r\n          <div className=\"detection-status\">\r\n            {error ? (\r\n              <div className=\"status-indicator error\" onClick={requestCameraPermission}>\r\n                {error} (Click to retry)\r\n              </div>\r\n            ) : isLoading ? (\r\n              <div className=\"status-indicator loading\">Loading model...</div>\r\n            ) : detected ? (\r\n              <div className=\"status-indicator detected\">\r\n                {facesDetected} face{facesDetected !== 1 ? 's' : ''} detected\r\n              </div>\r\n            ) : (\r\n              <div className=\"status-indicator not-detected\">No faces detected</div>\r\n            )}\r\n          </div>\r\n          {/* Debug visualization of bounding boxes */}\r\n          {!error && boundingBox && boundingBox.length > 0 && (\r\n            <svg\r\n              className=\"bounding-box-visualization\"\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                left: 0,\r\n                width: '100%',\r\n                height: '100%',\r\n              }}\r\n            >\r\n              {boundingBox.map((box, index) => (\r\n                <rect\r\n                  key={index}\r\n                  x={`${box.topLeft[0] / 640 * 100}%`}\r\n                  y={`${box.topLeft[1] / 480 * 100}%`}\r\n                  width={`${(box.bottomRight[0] - box.topLeft[0]) / 640 * 100}%`}\r\n                  height={`${(box.bottomRight[1] - box.topLeft[1]) / 480 * 100}%`}\r\n                  stroke=\"#00FFFF\"\r\n                  strokeWidth=\"2\"\r\n                  fill=\"none\"\r\n                />\r\n              ))}\r\n            </svg>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default FaceDetector; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}